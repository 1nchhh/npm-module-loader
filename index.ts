import fs from 'fs';
import path from 'path';

import type { x as TarX } from 'tar';

class Tar {
    promise: any;
    func: any;
    inited: boolean = false;

    constructor() {
        // @ts-ignore
        this.promise = new Promise(___resolve => { (() => { var t = { 9019: (t, e, i) => { "use strict"; const s = i(7147), r = i(1017), n = s.lchown ? "lchown" : "chown", h = s.lchownSync ? "lchownSync" : "chownSync", o = s.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), l = (t, e, i) => { try { return s[h](t, e, i) } catch (t) { if ("ENOENT" !== t.code) throw t } }, a = o ? (t, e, i, r) => n => { n && "EISDIR" === n.code ? s.chown(t, e, i, r) : r(n) } : (t, e, i, s) => s, c = o ? (t, e, i) => { try { return l(t, e, i) } catch (r) { if ("EISDIR" !== r.code) throw r; ((t, e, i) => { try { s.chownSync(t, e, i) } catch (t) { if ("ENOENT" !== t.code) throw t } })(t, e, i) } } : (t, e, i) => l(t, e, i), u = process.version; let d = (t, e, i) => s.readdir(t, e, i); /^v4\./.test(u) && (d = (t, e, i) => s.readdir(t, i)); const p = (t, e, i, r) => { s[n](t, e, i, a(t, e, i, (t => { r(t && "ENOENT" !== t.code ? t : null) }))) }, m = (t, e, i, n, h) => { if ("string" == typeof e) return s.lstat(r.resolve(t, e), ((s, r) => { if (s) return h("ENOENT" !== s.code ? s : null); r.name = e, m(t, r, i, n, h) })); if (e.isDirectory()) f(r.resolve(t, e.name), i, n, (s => { if (s) return h(s); const o = r.resolve(t, e.name); p(o, i, n, h) })); else { const s = r.resolve(t, e.name); p(s, i, n, h) } }, f = (t, e, i, s) => { d(t, { withFileTypes: !0 }, ((r, n) => { if (r) { if ("ENOENT" === r.code) return s(); if ("ENOTDIR" !== r.code && "ENOTSUP" !== r.code) return s(r) } if (r || !n.length) return p(t, e, i, s); let h = n.length, o = null; const l = r => { if (!o) return r ? s(o = r) : 0 == --h ? p(t, e, i, s) : void 0 }; n.forEach((s => m(t, s, e, i, l))) })) }, y = (t, e, i) => { let n; try { n = ((t, e) => s.readdirSync(t, { withFileTypes: !0 }))(t) } catch (s) { if ("ENOENT" === s.code) return; if ("ENOTDIR" === s.code || "ENOTSUP" === s.code) return c(t, e, i); throw s } return n && n.length && n.forEach((n => ((t, e, i, n) => { if ("string" == typeof e) try { const i = s.lstatSync(r.resolve(t, e)); i.name = e, e = i } catch (t) { if ("ENOENT" === t.code) return; throw t } e.isDirectory() && y(r.resolve(t, e.name), i, n), c(r.resolve(t, e.name), i, n) })(t, n, e, i))), c(t, e, i) }; t.exports = f, f.sync = y }, 292: (t, e, i) => { "use strict"; const s = i(5736), r = i(2361).EventEmitter, n = i(7147); let h = n.writev; if (!h) { const t = process.binding("fs"), e = t.FSReqWrap || t.FSReqCallback; h = (i, s, r, n) => { const h = new e; h.oncomplete = (t, e) => n(t, e, s), t.writeBuffers(i, s, r, h) } } const o = Symbol("_autoClose"), l = Symbol("_close"), a = Symbol("_ended"), c = Symbol("_fd"), u = Symbol("_finished"), d = Symbol("_flags"), p = Symbol("_flush"), m = Symbol("_handleChunk"), f = Symbol("_makeBuf"), y = Symbol("_mode"), b = Symbol("_needDrain"), w = Symbol("_onerror"), E = Symbol("_onopen"), S = Symbol("_onread"), _ = Symbol("_onwrite"), R = Symbol("_open"), g = Symbol("_path"), O = Symbol("_pos"), T = Symbol("_queue"), v = Symbol("_read"), k = Symbol("_readSize"), L = Symbol("_reading"), x = Symbol("_remain"), A = Symbol("_size"), I = Symbol("_write"), D = Symbol("_writing"), N = Symbol("_defaultFlag"), C = Symbol("_errored"); class B extends s { constructor(t, e) { if (super(e = e || {}), this.readable = !0, this.writable = !1, "string" != typeof t) throw new TypeError("path must be a string"); this[C] = !1, this[c] = "number" == typeof e.fd ? e.fd : null, this[g] = t, this[k] = e.readSize || 16777216, this[L] = !1, this[A] = "number" == typeof e.size ? e.size : 1 / 0, this[x] = this[A], this[o] = "boolean" != typeof e.autoClose || e.autoClose, "number" == typeof this[c] ? this[v]() : this[R]() } get fd() { return this[c] } get path() { return this[g] } write() { throw new TypeError("this is a readable stream") } end() { throw new TypeError("this is a readable stream") } [R]() { n.open(this[g], "r", ((t, e) => this[E](t, e))) } [E](t, e) { t ? this[w](t) : (this[c] = e, this.emit("open", e), this[v]()) } [f]() { return Buffer.allocUnsafe(Math.min(this[k], this[x])) } [v]() { if (!this[L]) { this[L] = !0; const t = this[f](); if (0 === t.length) return process.nextTick((() => this[S](null, 0, t))); n.read(this[c], t, 0, t.length, null, ((t, e, i) => this[S](t, e, i))) } } [S](t, e, i) { this[L] = !1, t ? this[w](t) : this[m](e, i) && this[v]() } [l]() { if (this[o] && "number" == typeof this[c]) { const t = this[c]; this[c] = null, n.close(t, (t => t ? this.emit("error", t) : this.emit("close"))) } } [w](t) { this[L] = !0, this[l](), this.emit("error", t) } [m](t, e) { let i = !1; return this[x] -= t, t > 0 && (i = super.write(t < e.length ? e.slice(0, t) : e)), (0 === t || this[x] <= 0) && (i = !1, this[l](), super.end()), i } emit(t, e) { switch (t) { case "prefinish": case "finish": break; case "drain": "number" == typeof this[c] && this[v](); break; case "error": if (this[C]) return; return this[C] = !0, super.emit(t, e); default: return super.emit(t, e) } } } class M extends r { constructor(t, e) { super(e = e || {}), this.readable = !1, this.writable = !0, this[C] = !1, this[D] = !1, this[a] = !1, this[b] = !1, this[T] = [], this[g] = t, this[c] = "number" == typeof e.fd ? e.fd : null, this[y] = void 0 === e.mode ? 438 : e.mode, this[O] = "number" == typeof e.start ? e.start : null, this[o] = "boolean" != typeof e.autoClose || e.autoClose; const i = null !== this[O] ? "r+" : "w"; this[N] = void 0 === e.flags, this[d] = this[N] ? i : e.flags, null === this[c] && this[R]() } emit(t, e) { if ("error" === t) { if (this[C]) return; this[C] = !0 } return super.emit(t, e) } get fd() { return this[c] } get path() { return this[g] } [w](t) { this[l](), this[D] = !0, this.emit("error", t) } [R]() { n.open(this[g], this[d], this[y], ((t, e) => this[E](t, e))) } [E](t, e) { this[N] && "r+" === this[d] && t && "ENOENT" === t.code ? (this[d] = "w", this[R]()) : t ? this[w](t) : (this[c] = e, this.emit("open", e), this[p]()) } end(t, e) { return t && this.write(t, e), this[a] = !0, this[D] || this[T].length || "number" != typeof this[c] || this[_](null, 0), this } write(t, e) { return "string" == typeof t && (t = Buffer.from(t, e)), this[a] ? (this.emit("error", new Error("write() after end()")), !1) : null === this[c] || this[D] || this[T].length ? (this[T].push(t), this[b] = !0, !1) : (this[D] = !0, this[I](t), !0) } [I](t) { n.write(this[c], t, 0, t.length, this[O], ((t, e) => this[_](t, e))) } [_](t, e) { t ? this[w](t) : (null !== this[O] && (this[O] += e), this[T].length ? this[p]() : (this[D] = !1, this[a] && !this[u] ? (this[u] = !0, this[l](), this.emit("finish")) : this[b] && (this[b] = !1, this.emit("drain")))) } [p]() { if (0 === this[T].length) this[a] && this[_](null, 0); else if (1 === this[T].length) this[I](this[T].pop()); else { const t = this[T]; this[T] = [], h(this[c], t, this[O], ((t, e) => this[_](t, e))) } } [l]() { if (this[o] && "number" == typeof this[c]) { const t = this[c]; this[c] = null, n.close(t, (t => t ? this.emit("error", t) : this.emit("close"))) } } } e.ReadStream = B, e.ReadStreamSync = class extends B { [R]() { let t = !0; try { this[E](null, n.openSync(this[g], "r")), t = !1 } finally { t && this[l]() } } [v]() { let t = !0; try { if (!this[L]) { for (this[L] = !0; ;) { const t = this[f](), e = 0 === t.length ? 0 : n.readSync(this[c], t, 0, t.length, null); if (!this[m](e, t)) break } this[L] = !1 } t = !1 } finally { t && this[l]() } } [l]() { if (this[o] && "number" == typeof this[c]) { const t = this[c]; this[c] = null, n.closeSync(t), this.emit("close") } } }, e.WriteStream = M, e.WriteStreamSync = class extends M { [R]() { let t; if (this[N] && "r+" === this[d]) try { t = n.openSync(this[g], this[d], this[y]) } catch (t) { if ("ENOENT" === t.code) return this[d] = "w", this[R](); throw t } else t = n.openSync(this[g], this[d], this[y]); this[E](null, t) } [l]() { if (this[o] && "number" == typeof this[c]) { const t = this[c]; this[c] = null, n.closeSync(t), this.emit("close") } } [I](t) { let e = !0; try { this[_](null, n.writeSync(this[c], t, 0, t.length, this[O])), e = !1 } finally { if (e) try { this[l]() } catch (t) { } } } } }, 5736: (t, e, i) => { "use strict"; const s = "object" == typeof process && process ? process : { stdout: null, stderr: null }, r = i(2361), n = i(2781), h = i(1576).StringDecoder, o = Symbol("EOF"), l = Symbol("maybeEmitEnd"), a = Symbol("emittedEnd"), c = Symbol("emittingEnd"), u = Symbol("emittedError"), d = Symbol("closed"), p = Symbol("read"), m = Symbol("flush"), f = Symbol("flushChunk"), y = Symbol("encoding"), b = Symbol("decoder"), w = Symbol("flowing"), E = Symbol("paused"), S = Symbol("resume"), _ = Symbol("bufferLength"), R = Symbol("bufferPush"), g = Symbol("bufferShift"), O = Symbol("objectMode"), T = Symbol("destroyed"), v = Symbol("emitData"), k = Symbol("emitEnd"), L = Symbol("emitEnd2"), x = Symbol("async"), A = t => Promise.resolve().then(t), I = "1" !== global._MP_NO_ITERATOR_SYMBOLS_, D = I && Symbol.asyncIterator || Symbol("asyncIterator not implemented"), N = I && Symbol.iterator || Symbol("iterator not implemented"); class C { constructor(t, e, i) { this.src = t, this.dest = e, this.opts = i, this.ondrain = () => t[S](), e.on("drain", this.ondrain) } unpipe() { this.dest.removeListener("drain", this.ondrain) } proxyErrors() { } end() { this.unpipe(), this.opts.end && this.dest.end() } } class B extends C { unpipe() { this.src.removeListener("error", this.proxyErrors), super.unpipe() } constructor(t, e, i) { super(t, e, i), this.proxyErrors = t => e.emit("error", t), t.on("error", this.proxyErrors) } } t.exports = class t extends n { constructor(t) { super(), this[w] = !1, this[E] = !1, this.pipes = [], this.buffer = [], this[O] = t && t.objectMode || !1, this[O] ? this[y] = null : this[y] = t && t.encoding || null, "buffer" === this[y] && (this[y] = null), this[x] = t && !!t.async || !1, this[b] = this[y] ? new h(this[y]) : null, this[o] = !1, this[a] = !1, this[c] = !1, this[d] = !1, this[u] = null, this.writable = !0, this.readable = !0, this[_] = 0, this[T] = !1 } get bufferLength() { return this[_] } get encoding() { return this[y] } set encoding(t) { if (this[O]) throw new Error("cannot set encoding in objectMode"); if (this[y] && t !== this[y] && (this[b] && this[b].lastNeed || this[_])) throw new Error("cannot change encoding"); this[y] !== t && (this[b] = t ? new h(t) : null, this.buffer.length && (this.buffer = this.buffer.map((t => this[b].write(t))))), this[y] = t } setEncoding(t) { this.encoding = t } get objectMode() { return this[O] } set objectMode(t) { this[O] = this[O] || !!t } get async() { return this[x] } set async(t) { this[x] = this[x] || !!t } write(t, e, i) { if (this[o]) throw new Error("write after end"); if (this[T]) return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0; "function" == typeof e && (i = e, e = "utf8"), e || (e = "utf8"); const s = this[x] ? A : t => t(); var r; return this[O] || Buffer.isBuffer(t) || (r = t, !Buffer.isBuffer(r) && ArrayBuffer.isView(r) ? t = Buffer.from(t.buffer, t.byteOffset, t.byteLength) : (t => t instanceof ArrayBuffer || "object" == typeof t && t.constructor && "ArrayBuffer" === t.constructor.name && t.byteLength >= 0)(t) ? t = Buffer.from(t) : "string" != typeof t && (this.objectMode = !0)), this[O] ? (this.flowing && 0 !== this[_] && this[m](!0), this.flowing ? this.emit("data", t) : this[R](t), 0 !== this[_] && this.emit("readable"), i && s(i), this.flowing) : t.length ? ("string" != typeof t || e === this[y] && !this[b].lastNeed || (t = Buffer.from(t, e)), Buffer.isBuffer(t) && this[y] && (t = this[b].write(t)), this.flowing && 0 !== this[_] && this[m](!0), this.flowing ? this.emit("data", t) : this[R](t), 0 !== this[_] && this.emit("readable"), i && s(i), this.flowing) : (0 !== this[_] && this.emit("readable"), i && s(i), this.flowing) } read(t) { if (this[T]) return null; if (0 === this[_] || 0 === t || t > this[_]) return this[l](), null; this[O] && (t = null), this.buffer.length > 1 && !this[O] && (this.encoding ? this.buffer = [this.buffer.join("")] : this.buffer = [Buffer.concat(this.buffer, this[_])]); const e = this[p](t || null, this.buffer[0]); return this[l](), e } [p](t, e) { return t === e.length || null === t ? this[g]() : (this.buffer[0] = e.slice(t), e = e.slice(0, t), this[_] -= t), this.emit("data", e), this.buffer.length || this[o] || this.emit("drain"), e } end(t, e, i) { return "function" == typeof t && (i = t, t = null), "function" == typeof e && (i = e, e = "utf8"), t && this.write(t, e), i && this.once("end", i), this[o] = !0, this.writable = !1, !this.flowing && this[E] || this[l](), this } [S]() { this[T] || (this[E] = !1, this[w] = !0, this.emit("resume"), this.buffer.length ? this[m]() : this[o] ? this[l]() : this.emit("drain")) } resume() { return this[S]() } pause() { this[w] = !1, this[E] = !0 } get destroyed() { return this[T] } get flowing() { return this[w] } get paused() { return this[E] } [R](t) { this[O] ? this[_] += 1 : this[_] += t.length, this.buffer.push(t) } [g]() { return this.buffer.length && (this[O] ? this[_] -= 1 : this[_] -= this.buffer[0].length), this.buffer.shift() } [m](t) { do { } while (this[f](this[g]())); t || this.buffer.length || this[o] || this.emit("drain") } [f](t) { return !!t && (this.emit("data", t), this.flowing) } pipe(t, e) { if (this[T]) return; const i = this[a]; return e = e || {}, t === s.stdout || t === s.stderr ? e.end = !1 : e.end = !1 !== e.end, e.proxyErrors = !!e.proxyErrors, i ? e.end && t.end() : (this.pipes.push(e.proxyErrors ? new B(this, t, e) : new C(this, t, e)), this[x] ? A((() => this[S]())) : this[S]()), t } unpipe(t) { const e = this.pipes.find((e => e.dest === t)); e && (this.pipes.splice(this.pipes.indexOf(e), 1), e.unpipe()) } addListener(t, e) { return this.on(t, e) } on(t, e) { const i = super.on(t, e); return "data" !== t || this.pipes.length || this.flowing ? "readable" === t && 0 !== this[_] ? super.emit("readable") : (t => "end" === t || "finish" === t || "prefinish" === t)(t) && this[a] ? (super.emit(t), this.removeAllListeners(t)) : "error" === t && this[u] && (this[x] ? A((() => e.call(this, this[u]))) : e.call(this, this[u])) : this[S](), i } get emittedEnd() { return this[a] } [l]() { this[c] || this[a] || this[T] || 0 !== this.buffer.length || !this[o] || (this[c] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[d] && this.emit("close"), this[c] = !1) } emit(t, e, ...i) { if ("error" !== t && "close" !== t && t !== T && this[T]) return; if ("data" === t) return !!e && (this[x] ? A((() => this[v](e))) : this[v](e)); if ("end" === t) return this[k](); if ("close" === t) { if (this[d] = !0, !this[a] && !this[T]) return; const t = super.emit("close"); return this.removeAllListeners("close"), t } if ("error" === t) { this[u] = e; const t = super.emit("error", e); return this[l](), t } if ("resume" === t) { const t = super.emit("resume"); return this[l](), t } if ("finish" === t || "prefinish" === t) { const e = super.emit(t); return this.removeAllListeners(t), e } const s = super.emit(t, e, ...i); return this[l](), s } [v](t) { for (const e of this.pipes) !1 === e.dest.write(t) && this.pause(); const e = super.emit("data", t); return this[l](), e } [k]() { this[a] || (this[a] = !0, this.readable = !1, this[x] ? A((() => this[L]())) : this[L]()) } [L]() { if (this[b]) { const t = this[b].end(); if (t) { for (const e of this.pipes) e.dest.write(t); super.emit("data", t) } } for (const t of this.pipes) t.end(); const t = super.emit("end"); return this.removeAllListeners("end"), t } collect() { const t = []; this[O] || (t.dataLength = 0); const e = this.promise(); return this.on("data", (e => { t.push(e), this[O] || (t.dataLength += e.length) })), e.then((() => t)) } concat() { return this[O] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((t => this[O] ? Promise.reject(new Error("cannot concat in objectMode")) : this[y] ? t.join("") : Buffer.concat(t, t.dataLength))) } promise() { return new Promise(((t, e) => { this.on(T, (() => e(new Error("stream destroyed")))), this.on("error", (t => e(t))), this.on("end", (() => t())) })) } [D]() { return { next: () => { const t = this.read(); if (null !== t) return Promise.resolve({ done: !1, value: t }); if (this[o]) return Promise.resolve({ done: !0 }); let e = null, i = null; const s = t => { this.removeListener("data", r), this.removeListener("end", n), i(t) }, r = t => { this.removeListener("error", s), this.removeListener("end", n), this.pause(), e({ value: t, done: !!this[o] }) }, n = () => { this.removeListener("error", s), this.removeListener("data", r), e({ done: !0 }) }, h = () => s(new Error("stream destroyed")); return new Promise(((t, o) => { i = o, e = t, this.once(T, h), this.once("error", s), this.once("end", n), this.once("data", r) })) } } } [N]() { return { next: () => { const t = this.read(); return { value: t, done: null === t } } } } destroy(t) { return this[T] ? (t ? this.emit("error", t) : this.emit(T), this) : (this[T] = !0, this.buffer.length = 0, this[_] = 0, "function" != typeof this.close || this[d] || this.close(), t ? this.emit("error", t) : this.emit(T), this) } static isStream(e) { return !!e && (e instanceof t || e instanceof n || e instanceof r && ("function" == typeof e.pipe || "function" == typeof e.write && "function" == typeof e.end)) } } }, 883: (t, e, i) => { const s = i(9796).constants || { ZLIB_VERNUM: 4736 }; t.exports = Object.freeze(Object.assign(Object.create(null), { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_VERSION_ERROR: -6, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, DEFLATE: 1, INFLATE: 2, GZIP: 3, GUNZIP: 4, DEFLATERAW: 5, INFLATERAW: 6, UNZIP: 7, BROTLI_DECODE: 8, BROTLI_ENCODE: 9, Z_MIN_WINDOWBITS: 8, Z_MAX_WINDOWBITS: 15, Z_DEFAULT_WINDOWBITS: 15, Z_MIN_CHUNK: 64, Z_MAX_CHUNK: 1 / 0, Z_DEFAULT_CHUNK: 16384, Z_MIN_MEMLEVEL: 1, Z_MAX_MEMLEVEL: 9, Z_DEFAULT_MEMLEVEL: 8, Z_MIN_LEVEL: -1, Z_MAX_LEVEL: 9, Z_DEFAULT_LEVEL: -1, BROTLI_OPERATION_PROCESS: 0, BROTLI_OPERATION_FLUSH: 1, BROTLI_OPERATION_FINISH: 2, BROTLI_OPERATION_EMIT_METADATA: 3, BROTLI_MODE_GENERIC: 0, BROTLI_MODE_TEXT: 1, BROTLI_MODE_FONT: 2, BROTLI_DEFAULT_MODE: 0, BROTLI_MIN_QUALITY: 0, BROTLI_MAX_QUALITY: 11, BROTLI_DEFAULT_QUALITY: 11, BROTLI_MIN_WINDOW_BITS: 10, BROTLI_MAX_WINDOW_BITS: 24, BROTLI_LARGE_MAX_WINDOW_BITS: 30, BROTLI_DEFAULT_WINDOW: 22, BROTLI_MIN_INPUT_BLOCK_BITS: 16, BROTLI_MAX_INPUT_BLOCK_BITS: 24, BROTLI_PARAM_MODE: 0, BROTLI_PARAM_QUALITY: 1, BROTLI_PARAM_LGWIN: 2, BROTLI_PARAM_LGBLOCK: 3, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4, BROTLI_PARAM_SIZE_HINT: 5, BROTLI_PARAM_LARGE_WINDOW: 6, BROTLI_PARAM_NPOSTFIX: 7, BROTLI_PARAM_NDIRECT: 8, BROTLI_DECODER_RESULT_ERROR: 0, BROTLI_DECODER_RESULT_SUCCESS: 1, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3, BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0, BROTLI_DECODER_PARAM_LARGE_WINDOW: 1, BROTLI_DECODER_NO_ERROR: 0, BROTLI_DECODER_SUCCESS: 1, BROTLI_DECODER_NEEDS_MORE_INPUT: 2, BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1, BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13, BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14, BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15, BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30, BROTLI_DECODER_ERROR_UNREACHABLE: -31 }, s)) }, 1650: (t, e, i) => { "use strict"; const s = i(9491), r = i(4300).Buffer, n = i(9796), h = e.constants = i(883), o = i(5736), l = r.concat, a = Symbol("_superWrite"); class c extends Error { constructor(t) { super("zlib: " + t.message), this.code = t.code, this.errno = t.errno, this.code || (this.code = "ZLIB_ERROR"), this.message = "zlib: " + t.message, Error.captureStackTrace(this, this.constructor) } get name() { return "ZlibError" } } const u = Symbol("opts"), d = Symbol("flushFlag"), p = Symbol("finishFlushFlag"), m = Symbol("fullFlushFlag"), f = Symbol("handle"), y = Symbol("onError"), b = Symbol("sawError"), w = Symbol("level"), E = Symbol("strategy"), S = Symbol("ended"); Symbol("_defaultFullFlush"); class _ extends o { constructor(t, e) { if (!t || "object" != typeof t) throw new TypeError("invalid options for ZlibBase constructor"); super(t), this[b] = !1, this[S] = !1, this[u] = t, this[d] = t.flush, this[p] = t.finishFlush; try { this[f] = new n[e](t) } catch (t) { throw new c(t) } this[y] = t => { this[b] || (this[b] = !0, this.close(), this.emit("error", t)) }, this[f].on("error", (t => this[y](new c(t)))), this.once("end", (() => this.close)) } close() { this[f] && (this[f].close(), this[f] = null, this.emit("close")) } reset() { if (!this[b]) return s(this[f], "zlib binding closed"), this[f].reset() } flush(t) { this.ended || ("number" != typeof t && (t = this[m]), this.write(Object.assign(r.alloc(0), { [d]: t }))) } end(t, e, i) { return t && this.write(t, e), this.flush(this[p]), this[S] = !0, super.end(null, null, i) } get ended() { return this[S] } write(t, e, i) { if ("function" == typeof e && (i = e, e = "utf8"), "string" == typeof t && (t = r.from(t, e)), this[b]) return; s(this[f], "zlib binding closed"); const n = this[f]._handle, h = n.close; n.close = () => { }; const o = this[f].close; let u, p; this[f].close = () => { }, r.concat = t => t; try { const e = "number" == typeof t[d] ? t[d] : this[d]; u = this[f]._processChunk(t, e), r.concat = l } catch (t) { r.concat = l, this[y](new c(t)) } finally { this[f] && (this[f]._handle = n, n.close = h, this[f].close = o, this[f].removeAllListeners("error")) } if (this[f] && this[f].on("error", (t => this[y](new c(t)))), u) if (Array.isArray(u) && u.length > 0) { p = this[a](r.from(u[0])); for (let t = 1; t < u.length; t++)p = this[a](u[t]) } else p = this[a](r.from(u)); return i && i(), p } [a](t) { return super.write(t) } } class R extends _ { constructor(t, e) { (t = t || {}).flush = t.flush || h.Z_NO_FLUSH, t.finishFlush = t.finishFlush || h.Z_FINISH, super(t, e), this[m] = h.Z_FULL_FLUSH, this[w] = t.level, this[E] = t.strategy } params(t, e) { if (!this[b]) { if (!this[f]) throw new Error("cannot switch params when binding is closed"); if (!this[f].params) throw new Error("not supported in this implementation"); if (this[w] !== t || this[E] !== e) { this.flush(h.Z_SYNC_FLUSH), s(this[f], "zlib binding closed"); const i = this[f].flush; this[f].flush = (t, e) => { this.flush(t), e() }; try { this[f].params(t, e) } finally { this[f].flush = i } this[f] && (this[w] = t, this[E] = e) } } } } const g = Symbol("_portable"); class O extends _ { constructor(t, e) { (t = t || {}).flush = t.flush || h.BROTLI_OPERATION_PROCESS, t.finishFlush = t.finishFlush || h.BROTLI_OPERATION_FINISH, super(t, e), this[m] = h.BROTLI_OPERATION_FLUSH } } e.Deflate = class extends R { constructor(t) { super(t, "Deflate") } }, e.Inflate = class extends R { constructor(t) { super(t, "Inflate") } }, e.Gzip = class extends R { constructor(t) { super(t, "Gzip"), this[g] = t && !!t.portable } [a](t) { return this[g] ? (this[g] = !1, t[9] = 255, super[a](t)) : super[a](t) } }, e.Gunzip = class extends R { constructor(t) { super(t, "Gunzip") } }, e.DeflateRaw = class extends R { constructor(t) { super(t, "DeflateRaw") } }, e.InflateRaw = class extends R { constructor(t) { super(t, "InflateRaw") } }, e.Unzip = class extends R { constructor(t) { super(t, "Unzip") } }, "function" == typeof n.BrotliCompress ? (e.BrotliCompress = class extends O { constructor(t) { super(t, "BrotliCompress") } }, e.BrotliDecompress = class extends O { constructor(t) { super(t, "BrotliDecompress") } }) : e.BrotliCompress = e.BrotliDecompress = class { constructor() { throw new Error("Brotli is not supported in this version of Node.js") } } }, 1890: (t, e, i) => { const s = i(4231), r = i(3610), { mkdirpNative: n, mkdirpNativeSync: h } = i(9378), { mkdirpManual: o, mkdirpManualSync: l } = i(8600), { useNative: a, useNativeSync: c } = i(6167), u = (t, e) => (t = r(t), e = s(e), a(e) ? n(t, e) : o(t, e)); u.sync = (t, e) => (t = r(t), e = s(e), c(e) ? h(t, e) : l(t, e)), u.native = (t, e) => n(r(t), s(e)), u.manual = (t, e) => o(r(t), s(e)), u.nativeSync = (t, e) => h(r(t), s(e)), u.manualSync = (t, e) => l(r(t), s(e)), t.exports = u }, 8812: (t, e, i) => { const { dirname: s } = i(1017), r = (t, e, i) => i === e ? Promise.resolve() : t.statAsync(e).then((t => t.isDirectory() ? i : void 0), (i => "ENOENT" === i.code ? r(t, s(e), e) : void 0)), n = (t, e, i) => { if (i !== e) try { return t.statSync(e).isDirectory() ? i : void 0 } catch (i) { return "ENOENT" === i.code ? n(t, s(e), e) : void 0 } }; t.exports = { findMade: r, findMadeSync: n } }, 8600: (t, e, i) => { const { dirname: s } = i(1017), r = (t, e, i) => { e.recursive = !1; const n = s(t); return n === t ? e.mkdirAsync(t, e).catch((t => { if ("EISDIR" !== t.code) throw t })) : e.mkdirAsync(t, e).then((() => i || t), (s => { if ("ENOENT" === s.code) return r(n, e).then((i => r(t, e, i))); if ("EEXIST" !== s.code && "EROFS" !== s.code) throw s; return e.statAsync(t).then((t => { if (t.isDirectory()) return i; throw s }), (() => { throw s })) })) }, n = (t, e, i) => { const r = s(t); if (e.recursive = !1, r === t) try { return e.mkdirSync(t, e) } catch (t) { if ("EISDIR" !== t.code) throw t; return } try { return e.mkdirSync(t, e), i || t } catch (s) { if ("ENOENT" === s.code) return n(t, e, n(r, e, i)); if ("EEXIST" !== s.code && "EROFS" !== s.code) throw s; try { if (!e.statSync(t).isDirectory()) throw s } catch (t) { throw s } } }; t.exports = { mkdirpManual: r, mkdirpManualSync: n } }, 9378: (t, e, i) => { const { dirname: s } = i(1017), { findMade: r, findMadeSync: n } = i(8812), { mkdirpManual: h, mkdirpManualSync: o } = i(8600); t.exports = { mkdirpNative: (t, e) => (e.recursive = !0, s(t) === t ? e.mkdirAsync(t, e) : r(e, t).then((i => e.mkdirAsync(t, e).then((() => i)).catch((i => { if ("ENOENT" === i.code) return h(t, e); throw i }))))), mkdirpNativeSync: (t, e) => { if (e.recursive = !0, s(t) === t) return e.mkdirSync(t, e); const i = n(e, t); try { return e.mkdirSync(t, e), i } catch (i) { if ("ENOENT" === i.code) return o(t, e); throw i } } } }, 4231: (t, e, i) => { const { promisify: s } = i(3837), r = i(7147); t.exports = t => { if (t) if ("object" == typeof t) t = { mode: 511, fs: r, ...t }; else if ("number" == typeof t) t = { mode: t, fs: r }; else { if ("string" != typeof t) throw new TypeError("invalid options argument"); t = { mode: parseInt(t, 8), fs: r } } else t = { mode: 511, fs: r }; return t.mkdir = t.mkdir || t.fs.mkdir || r.mkdir, t.mkdirAsync = s(t.mkdir), t.stat = t.stat || t.fs.stat || r.stat, t.statAsync = s(t.stat), t.statSync = t.statSync || t.fs.statSync || r.statSync, t.mkdirSync = t.mkdirSync || t.fs.mkdirSync || r.mkdirSync, t } }, 3610: (t, e, i) => { const s = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, { resolve: r, parse: n } = i(1017); t.exports = t => { if (/\0/.test(t)) throw Object.assign(new TypeError("path must be a string without null bytes"), { path: t, code: "ERR_INVALID_ARG_VALUE" }); if (t = r(t), "win32" === s) { const e = /[*|"<>?:]/, { root: i } = n(t); if (e.test(t.substr(i.length))) throw Object.assign(new Error("Illegal characters in path."), { path: t, code: "EINVAL" }) } return t } }, 6167: (t, e, i) => { const s = i(7147), r = (process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version).replace(/^v/, "").split("."), n = +r[0] > 10 || 10 == +r[0] && +r[1] >= 12, h = n ? t => t.mkdir === s.mkdir : () => !1, o = n ? t => t.mkdirSync === s.mkdirSync : () => !1; t.exports = { useNative: h, useNativeSync: o } }, 7998: (t, e, i) => { "use strict"; e.c = e.create = i(4629), e.r = e.replace = i(1746), e.t = e.list = i(6473), e.u = e.update = i(5997), e.x = e.extract = i(769), e.Pack = i(8042), e.Unpack = i(2699), e.Parse = i(6824), e.ReadEntry = i(6277), e.WriteEntry = i(7620), e.Header = i(7134), e.Pax = i(4747), e.types = i(4402) }, 4629: (t, e, i) => { "use strict"; const s = i(2093), r = i(8042), n = i(292), h = i(6473), o = i(1017); t.exports = (t, e, i) => { if ("function" == typeof e && (i = e), Array.isArray(t) && (e = t, t = {}), !e || !Array.isArray(e) || !e.length) throw new TypeError("no files or directories specified"); e = Array.from(e); const r = s(t); if (r.sync && "function" == typeof i) throw new TypeError("callback not supported for sync tar functions"); if (!r.file && "function" == typeof i) throw new TypeError("callback only supported with file option"); return r.file && r.sync ? l(r, e) : r.file ? a(r, e, i) : r.sync ? d(r, e) : p(r, e) }; const l = (t, e) => { const i = new r.Sync(t), s = new n.WriteStreamSync(t.file, { mode: t.mode || 438 }); i.pipe(s), c(i, e) }, a = (t, e, i) => { const s = new r(t), h = new n.WriteStream(t.file, { mode: t.mode || 438 }); s.pipe(h); const o = new Promise(((t, e) => { h.on("error", e), h.on("close", t), s.on("error", e) })); return u(s, e), i ? o.then(i, i) : o }, c = (t, e) => { e.forEach((e => { "@" === e.charAt(0) ? h({ file: o.resolve(t.cwd, e.substr(1)), sync: !0, noResume: !0, onentry: e => t.add(e) }) : t.add(e) })), t.end() }, u = (t, e) => { for (; e.length;) { const i = e.shift(); if ("@" === i.charAt(0)) return h({ file: o.resolve(t.cwd, i.substr(1)), noResume: !0, onentry: e => t.add(e) }).then((i => u(t, e))); t.add(i) } t.end() }, d = (t, e) => { const i = new r.Sync(t); return c(i, e), i }, p = (t, e) => { const i = new r(t); return u(i, e), i } }, 769: (t, e, i) => { "use strict"; const s = i(2093), r = i(2699), n = i(7147), h = i(292), o = i(1017), l = i(4922); t.exports = (t, e, i) => { "function" == typeof t ? (i = t, e = null, t = {}) : Array.isArray(t) && (e = t, t = {}), "function" == typeof e && (i = e, e = null), e = e ? Array.from(e) : []; const r = s(t); if (r.sync && "function" == typeof i) throw new TypeError("callback not supported for sync tar functions"); if (!r.file && "function" == typeof i) throw new TypeError("callback only supported with file option"); return e.length && a(r, e), r.file && r.sync ? c(r) : r.file ? u(r, i) : r.sync ? d(r) : p(r) }; const a = (t, e) => { const i = new Map(e.map((t => [l(t), !0]))), s = t.filter, r = (t, e) => { const s = e || o.parse(t).root || ".", n = t !== s && (i.has(t) ? i.get(t) : r(o.dirname(t), s)); return i.set(t, n), n }; t.filter = s ? (t, e) => s(t, e) && r(l(t)) : t => r(l(t)) }, c = t => { const e = new r.Sync(t), i = t.file, s = n.statSync(i), o = t.maxReadSize || 16777216; new h.ReadStreamSync(i, { readSize: o, size: s.size }).pipe(e) }, u = (t, e) => { const i = new r(t), s = t.maxReadSize || 16777216, o = t.file, l = new Promise(((t, e) => { i.on("error", e), i.on("close", t), n.stat(o, ((t, r) => { if (t) e(t); else { const t = new h.ReadStream(o, { readSize: s, size: r.size }); t.on("error", e), t.pipe(i) } })) })); return e ? l.then(e, e) : l }, d = t => new r.Sync(t), p = t => new r(t) }, 5879: (t, e, i) => { const s = "win32" === (process.env.__FAKE_PLATFORM__ || process.platform), r = global.__FAKE_TESTING_FS__ || i(7147), { O_CREAT: n, O_TRUNC: h, O_WRONLY: o, UV_FS_O_FILEMAP: l = 0 } = r.constants, a = s && !!l, c = l | h | n | o; t.exports = a ? t => t < 524288 ? c : "w" : () => "w" }, 7134: (t, e, i) => { "use strict"; const s = i(4402), r = i(1017).posix, n = i(9678), h = Symbol("slurp"), o = Symbol("type"), l = (t, e, i) => t.slice(e, e + i).toString("utf8").replace(/\0.*/, ""), a = (t, e, i) => c(u(t, e, i)), c = t => null === t ? null : new Date(1e3 * t), u = (t, e, i) => 128 & t[e] ? n.parse(t.slice(e, e + i)) : d(t, e, i), d = (t, e, i) => { return s = parseInt(t.slice(e, e + i).toString("utf8").replace(/\0.*$/, "").trim(), 8), isNaN(s) ? null : s; var s }, p = { 12: 8589934591, 8: 2097151 }, m = (t, e, i, s) => null !== s && (s > p[i] || s < 0 ? (n.encode(s, t.slice(e, e + i)), !0) : (f(t, e, i, s), !1)), f = (t, e, i, s) => t.write(y(s, i), e, i, "ascii"), y = (t, e) => b(Math.floor(t).toString(8), e), b = (t, e) => (t.length === e - 1 ? t : new Array(e - t.length - 1).join("0") + t + " ") + "\0", w = (t, e, i, s) => null !== s && m(t, e, i, s.getTime() / 1e3), E = new Array(156).join("\0"), S = (t, e, i, s) => null !== s && (t.write(s + E, e, i, "utf8"), s.length !== Buffer.byteLength(s) || s.length > i); t.exports = class { constructor(t, e, i, s) { this.cksumValid = !1, this.needPax = !1, this.nullBlock = !1, this.block = null, this.path = null, this.mode = null, this.uid = null, this.gid = null, this.size = null, this.mtime = null, this.cksum = null, this[o] = "0", this.linkpath = null, this.uname = null, this.gname = null, this.devmaj = 0, this.devmin = 0, this.atime = null, this.ctime = null, Buffer.isBuffer(t) ? this.decode(t, e || 0, i, s) : t && this.set(t) } decode(t, e, i, s) { if (e || (e = 0), !(t && t.length >= e + 512)) throw new Error("need 512 bytes for header"); if (this.path = l(t, e, 100), this.mode = u(t, e + 100, 8), this.uid = u(t, e + 108, 8), this.gid = u(t, e + 116, 8), this.size = u(t, e + 124, 12), this.mtime = a(t, e + 136, 12), this.cksum = u(t, e + 148, 12), this[h](i), this[h](s, !0), this[o] = l(t, e + 156, 1), "" === this[o] && (this[o] = "0"), "0" === this[o] && "/" === this.path.substr(-1) && (this[o] = "5"), "5" === this[o] && (this.size = 0), this.linkpath = l(t, e + 157, 100), "ustar\x0000" === t.slice(e + 257, e + 265).toString()) if (this.uname = l(t, e + 265, 32), this.gname = l(t, e + 297, 32), this.devmaj = u(t, e + 329, 8), this.devmin = u(t, e + 337, 8), 0 !== t[e + 475]) { const i = l(t, e + 345, 155); this.path = i + "/" + this.path } else { const i = l(t, e + 345, 130); i && (this.path = i + "/" + this.path), this.atime = a(t, e + 476, 12), this.ctime = a(t, e + 488, 12) } let r = 256; for (let i = e; i < e + 148; i++)r += t[i]; for (let i = e + 156; i < e + 512; i++)r += t[i]; this.cksumValid = r === this.cksum, null === this.cksum && 256 === r && (this.nullBlock = !0) } [h](t, e) { for (const i in t) null === t[i] || void 0 === t[i] || e && "path" === i || (this[i] = t[i]) } encode(t, e) { if (t || (t = this.block = Buffer.alloc(512), e = 0), e || (e = 0), !(t.length >= e + 512)) throw new Error("need 512 bytes for header"); const i = this.ctime || this.atime ? 130 : 155, s = ((t, e) => { let i, s = t, n = ""; const h = r.parse(t).root || "."; if (Buffer.byteLength(s) < 100) i = [s, n, !1]; else { n = r.dirname(s), s = r.basename(s); do { Buffer.byteLength(s) <= 100 && Buffer.byteLength(n) <= e ? i = [s, n, !1] : Buffer.byteLength(s) > 100 && Buffer.byteLength(n) <= e ? i = [s.substr(0, 99), n, !0] : (s = r.join(r.basename(n), s), n = r.dirname(n)) } while (n !== h && !i); i || (i = [t.substr(0, 99), "", !0]) } return i })(this.path || "", i), n = s[0], h = s[1]; this.needPax = s[2], this.needPax = S(t, e, 100, n) || this.needPax, this.needPax = m(t, e + 100, 8, this.mode) || this.needPax, this.needPax = m(t, e + 108, 8, this.uid) || this.needPax, this.needPax = m(t, e + 116, 8, this.gid) || this.needPax, this.needPax = m(t, e + 124, 12, this.size) || this.needPax, this.needPax = w(t, e + 136, 12, this.mtime) || this.needPax, t[e + 156] = this[o].charCodeAt(0), this.needPax = S(t, e + 157, 100, this.linkpath) || this.needPax, t.write("ustar\x0000", e + 257, 8), this.needPax = S(t, e + 265, 32, this.uname) || this.needPax, this.needPax = S(t, e + 297, 32, this.gname) || this.needPax, this.needPax = m(t, e + 329, 8, this.devmaj) || this.needPax, this.needPax = m(t, e + 337, 8, this.devmin) || this.needPax, this.needPax = S(t, e + 345, i, h) || this.needPax, 0 !== t[e + 475] ? this.needPax = S(t, e + 345, 155, h) || this.needPax : (this.needPax = S(t, e + 345, 130, h) || this.needPax, this.needPax = w(t, e + 476, 12, this.atime) || this.needPax, this.needPax = w(t, e + 488, 12, this.ctime) || this.needPax); let l = 256; for (let i = e; i < e + 148; i++)l += t[i]; for (let i = e + 156; i < e + 512; i++)l += t[i]; return this.cksum = l, m(t, e + 148, 8, this.cksum), this.cksumValid = !0, this.needPax } set(t) { for (const e in t) null !== t[e] && void 0 !== t[e] && (this[e] = t[e]) } get type() { return s.name.get(this[o]) || this[o] } get typeKey() { return this[o] } set type(t) { s.code.has(t) ? this[o] = s.code.get(t) : this[o] = t } } }, 2093: t => { "use strict"; const e = new Map([["C", "cwd"], ["f", "file"], ["z", "gzip"], ["P", "preservePaths"], ["U", "unlink"], ["strip-components", "strip"], ["stripComponents", "strip"], ["keep-newer", "newer"], ["keepNewer", "newer"], ["keep-newer-files", "newer"], ["keepNewerFiles", "newer"], ["k", "keep"], ["keep-existing", "keep"], ["keepExisting", "keep"], ["m", "noMtime"], ["no-mtime", "noMtime"], ["p", "preserveOwner"], ["L", "follow"], ["h", "follow"]]); t.exports = t => t ? Object.keys(t).map((i => [e.has(i) ? e.get(i) : i, t[i]])).reduce(((t, e) => (t[e[0]] = e[1], t)), Object.create(null)) : {} }, 9678: t => { "use strict"; const e = t => 255 & (255 ^ t), i = t => 1 + (255 ^ t) & 255; t.exports = { encode: (t, s) => { if (!Number.isSafeInteger(t)) throw Error("cannot encode number outside of javascript safe integer range"); return t < 0 ? ((t, s) => { s[0] = 255; var r = !1; t *= -1; for (var n = s.length; n > 1; n--) { var h = 255 & t; t = Math.floor(t / 256), r ? s[n - 1] = e(h) : 0 === h ? s[n - 1] = 0 : (r = !0, s[n - 1] = i(h)) } })(t, s) : ((t, e) => { e[0] = 128; for (var i = e.length; i > 1; i--)e[i - 1] = 255 & t, t = Math.floor(t / 256) })(t, s), s }, parse: t => { const s = t[0], r = 128 === s ? (t => { for (var e = t.length, i = 0, s = e - 1; s > -1; s--) { var r = t[s]; 0 !== r && (i += r * Math.pow(256, e - s - 1)) } return i })(t.slice(1, t.length)) : 255 === s ? (t => { for (var s = t.length, r = 0, n = !1, h = s - 1; h > -1; h--) { var o, l = t[h]; n ? o = e(l) : 0 === l ? o = l : (n = !0, o = i(l)), 0 !== o && (r -= o * Math.pow(256, s - h - 1)) } return r })(t) : null; if (null === r) throw Error("invalid base256 encoding"); if (!Number.isSafeInteger(r)) throw Error("parsed number outside of javascript safe integer range"); return r } } }, 6473: (t, e, i) => { "use strict"; const s = i(2093), r = i(6824), n = i(7147), h = i(292), o = i(1017), l = i(4922); t.exports = (t, e, i) => { "function" == typeof t ? (i = t, e = null, t = {}) : Array.isArray(t) && (e = t, t = {}), "function" == typeof e && (i = e, e = null), e = e ? Array.from(e) : []; const r = s(t); if (r.sync && "function" == typeof i) throw new TypeError("callback not supported for sync tar functions"); if (!r.file && "function" == typeof i) throw new TypeError("callback only supported with file option"); return e.length && c(r, e), r.noResume || a(r), r.file && r.sync ? u(r) : r.file ? d(r, i) : p(r) }; const a = t => { const e = t.onentry; t.onentry = e ? t => { e(t), t.resume() } : t => t.resume() }, c = (t, e) => { const i = new Map(e.map((t => [l(t), !0]))), s = t.filter, r = (t, e) => { const s = e || o.parse(t).root || ".", n = t !== s && (i.has(t) ? i.get(t) : r(o.dirname(t), s)); return i.set(t, n), n }; t.filter = s ? (t, e) => s(t, e) && r(l(t)) : t => r(l(t)) }, u = t => { const e = p(t), i = t.file; let s, r = !0; try { const h = n.statSync(i), o = t.maxReadSize || 16777216; if (h.size < o) e.end(n.readFileSync(i)); else { let t = 0; const r = Buffer.allocUnsafe(o); for (s = n.openSync(i, "r"); t < h.size;) { const i = n.readSync(s, r, 0, o, t); t += i, e.write(r.slice(0, i)) } e.end() } r = !1 } finally { if (r && s) try { n.closeSync(s) } catch (t) { } } }, d = (t, e) => { const i = new r(t), s = t.maxReadSize || 16777216, o = t.file, l = new Promise(((t, e) => { i.on("error", e), i.on("end", t), n.stat(o, ((t, r) => { if (t) e(t); else { const t = new h.ReadStream(o, { readSize: s, size: r.size }); t.on("error", e), t.pipe(i) } })) })); return e ? l.then(e, e) : l }, p = t => new r(t) }, 3248: (t, e, i) => { "use strict"; const s = i(1890), r = i(7147), n = i(1017), h = i(9019), o = i(2905); class l extends Error { constructor(t, e) { super("Cannot extract through symbolic link"), this.path = e, this.symlink = t } get name() { return "SylinkError" } } class a extends Error { constructor(t, e) { super(e + ": Cannot cd into '" + t + "'"), this.path = t, this.code = e } get name() { return "CwdError" } } const c = (t, e) => t.get(o(e)), u = (t, e, i) => t.set(o(e), i); t.exports = (t, e, i) => { t = o(t); const l = e.umask, p = 448 | e.mode, m = 0 != (p & l), f = e.uid, y = e.gid, b = "number" == typeof f && "number" == typeof y && (f !== e.processUid || y !== e.processGid), w = e.preserve, E = e.unlink, S = e.cache, _ = o(e.cwd), R = (e, s) => { e ? i(e) : (u(S, t, !0), s && b ? h(s, f, y, (t => R(t))) : m ? r.chmod(t, p, i) : i()) }; if (S && !0 === c(S, t)) return R(); if (t === _) return ((t, e) => { r.stat(t, ((i, s) => { !i && s.isDirectory() || (i = new a(t, i && i.code || "ENOTDIR")), e(i) })) })(t, R); if (w) return s(t, { mode: p }).then((t => R(null, t)), R); const g = o(n.relative(_, t)).split("/"); d(_, g, p, S, E, _, null, R) }; const d = (t, e, i, s, h, l, a, u) => { if (!e.length) return u(null, a); const m = e.shift(), f = o(n.resolve(t + "/" + m)); if (c(s, f)) return d(f, e, i, s, h, l, a, u); r.mkdir(f, i, p(f, e, i, s, h, l, a, u)) }, p = (t, e, i, s, n, h, a, c) => u => { u ? r.lstat(t, ((m, f) => { if (m) m.path = m.path && o(m.path), c(m); else if (f.isDirectory()) d(t, e, i, s, n, h, a, c); else if (n) r.unlink(t, (o => { if (o) return c(o); r.mkdir(t, i, p(t, e, i, s, n, h, a, c)) })); else { if (f.isSymbolicLink()) return c(new l(t, t + "/" + e.join("/"))); c(u) } })) : d(t, e, i, s, n, h, a = a || t, c) }; t.exports.sync = (t, e) => { t = o(t); const i = e.umask, d = 448 | e.mode, p = 0 != (d & i), m = e.uid, f = e.gid, y = "number" == typeof m && "number" == typeof f && (m !== e.processUid || f !== e.processGid), b = e.preserve, w = e.unlink, E = e.cache, S = o(e.cwd), _ = e => { u(E, t, !0), e && y && h.sync(e, m, f), p && r.chmodSync(t, d) }; if (E && !0 === c(E, t)) return _(); if (t === S) return (t => { let e = !1, i = "ENOTDIR"; try { e = r.statSync(t).isDirectory() } catch (t) { i = t.code } finally { if (!e) throw new a(t, i) } })(S), _(); if (b) return _(s.sync(t, d)); const R = o(n.relative(S, t)).split("/"); let g = null; for (let t = R.shift(), e = S; t && (e += "/" + t); t = R.shift())if (e = o(n.resolve(e)), !c(E, e)) try { r.mkdirSync(e, d), g = g || e, u(E, e, !0) } catch (t) { const i = r.lstatSync(e); if (i.isDirectory()) { u(E, e, !0); continue } if (w) { r.unlinkSync(e), r.mkdirSync(e, d), g = g || e, u(E, e, !0); continue } if (i.isSymbolicLink()) return new l(e, e + "/" + R.join("/")) } return _(g) } }, 7716: t => { "use strict"; t.exports = (t, e, i) => (t &= 4095, i && (t = -19 & (384 | t)), e && (256 & t && (t |= 64), 32 & t && (t |= 8), 4 & t && (t |= 1)), t) }, 1946: t => { const e = Object.create(null), { hasOwnProperty: i } = Object.prototype; t.exports = t => (i.call(e, t) || (e[t] = t.normalize("NFKD")), e[t]) }, 2905: t => { const e = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform; t.exports = "win32" !== e ? t => t : t => t && t.replace(/\\/g, "/") }, 8042: (t, e, i) => { "use strict"; class s { constructor(t, e) { this.path = t || "./", this.absolute = e, this.entry = null, this.stat = null, this.readdir = null, this.pending = !1, this.ignore = !1, this.piped = !1 } } const r = i(5736), n = i(1650), h = i(6277), o = i(7620), l = o.Sync, a = o.Tar, c = i(4411), u = Buffer.alloc(1024), d = Symbol("onStat"), p = Symbol("ended"), m = Symbol("queue"), f = Symbol("current"), y = Symbol("process"), b = Symbol("processing"), w = Symbol("processJob"), E = Symbol("jobs"), S = Symbol("jobDone"), _ = Symbol("addFSEntry"), R = Symbol("addTarEntry"), g = Symbol("stat"), O = Symbol("readdir"), T = Symbol("onreaddir"), v = Symbol("pipe"), k = Symbol("entry"), L = Symbol("entryOpt"), x = Symbol("writeEntryClass"), A = Symbol("write"), I = Symbol("ondrain"), D = i(7147), N = i(1017), C = i(7902), B = i(2905), M = C(class extends r { constructor(t) { super(t), t = t || Object.create(null), this.opt = t, this.file = t.file || "", this.cwd = t.cwd || process.cwd(), this.maxReadSize = t.maxReadSize, this.preservePaths = !!t.preservePaths, this.strict = !!t.strict, this.noPax = !!t.noPax, this.prefix = B(t.prefix || ""), this.linkCache = t.linkCache || new Map, this.statCache = t.statCache || new Map, this.readdirCache = t.readdirCache || new Map, this[x] = o, "function" == typeof t.onwarn && this.on("warn", t.onwarn), this.portable = !!t.portable, this.zip = null, t.gzip ? ("object" != typeof t.gzip && (t.gzip = {}), this.portable && (t.gzip.portable = !0), this.zip = new n.Gzip(t.gzip), this.zip.on("data", (t => super.write(t))), this.zip.on("end", (t => super.end())), this.zip.on("drain", (t => this[I]())), this.on("resume", (t => this.zip.resume()))) : this.on("drain", this[I]), this.noDirRecurse = !!t.noDirRecurse, this.follow = !!t.follow, this.noMtime = !!t.noMtime, this.mtime = t.mtime || null, this.filter = "function" == typeof t.filter ? t.filter : t => !0, this[m] = new c, this[E] = 0, this.jobs = +t.jobs || 4, this[b] = !1, this[p] = !1 } [A](t) { return super.write(t) } add(t) { return this.write(t), this } end(t) { return t && this.write(t), this[p] = !0, this[y](), this } write(t) { if (this[p]) throw new Error("write after end"); return t instanceof h ? this[R](t) : this[_](t), this.flowing } [R](t) { const e = B(N.resolve(this.cwd, t.path)); if (this.filter(t.path, t)) { const i = new s(t.path, e, !1); i.entry = new a(t, this[L](i)), i.entry.on("end", (t => this[S](i))), this[E] += 1, this[m].push(i) } else t.resume(); this[y]() } [_](t) { const e = B(N.resolve(this.cwd, t)); this[m].push(new s(t, e)), this[y]() } [g](t) { t.pending = !0, this[E] += 1; const e = this.follow ? "stat" : "lstat"; D[e](t.absolute, ((e, i) => { t.pending = !1, this[E] -= 1, e ? this.emit("error", e) : this[d](t, i) })) } [d](t, e) { this.statCache.set(t.absolute, e), t.stat = e, this.filter(t.path, e) || (t.ignore = !0), this[y]() } [O](t) { t.pending = !0, this[E] += 1, D.readdir(t.absolute, ((e, i) => { if (t.pending = !1, this[E] -= 1, e) return this.emit("error", e); this[T](t, i) })) } [T](t, e) { this.readdirCache.set(t.absolute, e), t.readdir = e, this[y]() } [y]() { if (!this[b]) { this[b] = !0; for (let t = this[m].head; null !== t && this[E] < this.jobs; t = t.next)if (this[w](t.value), t.value.ignore) { const e = t.next; this[m].removeNode(t), t.next = e } this[b] = !1, this[p] && !this[m].length && 0 === this[E] && (this.zip ? this.zip.end(u) : (super.write(u), super.end())) } } get [f]() { return this[m] && this[m].head && this[m].head.value } [S](t) { this[m].shift(), this[E] -= 1, this[y]() } [w](t) { t.pending || (t.entry ? t !== this[f] || t.piped || this[v](t) : (t.stat || (this.statCache.has(t.absolute) ? this[d](t, this.statCache.get(t.absolute)) : this[g](t)), t.stat && (t.ignore || (this.noDirRecurse || !t.stat.isDirectory() || t.readdir || (this.readdirCache.has(t.absolute) ? this[T](t, this.readdirCache.get(t.absolute)) : this[O](t), t.readdir)) && (t.entry = this[k](t), t.entry ? t !== this[f] || t.piped || this[v](t) : t.ignore = !0)))) } [L](t) { return { onwarn: (t, e, i) => this.warn(t, e, i), noPax: this.noPax, cwd: this.cwd, absolute: t.absolute, preservePaths: this.preservePaths, maxReadSize: this.maxReadSize, strict: this.strict, portable: this.portable, linkCache: this.linkCache, statCache: this.statCache, noMtime: this.noMtime, mtime: this.mtime, prefix: this.prefix } } [k](t) { this[E] += 1; try { return new this[x](t.path, this[L](t)).on("end", (() => this[S](t))).on("error", (t => this.emit("error", t))) } catch (t) { this.emit("error", t) } } [I]() { this[f] && this[f].entry && this[f].entry.resume() } [v](t) { t.piped = !0, t.readdir && t.readdir.forEach((e => { const i = t.path, s = "./" === i ? "" : i.replace(/\/*$/, "/"); this[_](s + e) })); const e = t.entry, i = this.zip; i ? e.on("data", (t => { i.write(t) || e.pause() })) : e.on("data", (t => { super.write(t) || e.pause() })) } pause() { return this.zip && this.zip.pause(), super.pause() } }); M.Sync = class extends M { constructor(t) { super(t), this[x] = l } pause() { } resume() { } [g](t) { const e = this.follow ? "statSync" : "lstatSync"; this[d](t, D[e](t.absolute)) } [O](t, e) { this[T](t, D.readdirSync(t.absolute)) } [v](t) { const e = t.entry, i = this.zip; t.readdir && t.readdir.forEach((e => { const i = t.path, s = "./" === i ? "" : i.replace(/\/*$/, "/"); this[_](s + e) })), i ? e.on("data", (t => { i.write(t) })) : e.on("data", (t => { super[A](t) })) } }, t.exports = M }, 6824: (t, e, i) => { "use strict"; const s = i(7902), r = i(7134), n = i(2361), h = i(4411), o = i(6277), l = i(4747), a = i(1650), c = Buffer.from([31, 139]), u = Symbol("state"), d = Symbol("writeEntry"), p = Symbol("readEntry"), m = Symbol("nextEntry"), f = Symbol("processEntry"), y = Symbol("extendedHeader"), b = Symbol("globalExtendedHeader"), w = Symbol("meta"), E = Symbol("emitMeta"), S = Symbol("buffer"), _ = Symbol("queue"), R = Symbol("ended"), g = Symbol("emittedEnd"), O = Symbol("emit"), T = Symbol("unzip"), v = Symbol("consumeChunk"), k = Symbol("consumeChunkSub"), L = Symbol("consumeBody"), x = Symbol("consumeMeta"), A = Symbol("consumeHeader"), I = Symbol("consuming"), D = Symbol("bufferConcat"), N = Symbol("maybeEnd"), C = Symbol("writing"), B = Symbol("aborted"), M = Symbol("onDone"), F = Symbol("sawValidEntry"), P = Symbol("sawNullBlock"), z = Symbol("sawEOF"), U = t => !0; t.exports = s(class extends n { constructor(t) { super(t = t || {}), this.file = t.file || "", this[F] = null, this.on(M, (t => { "begin" !== this[u] && !1 !== this[F] || this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format") })), t.ondone ? this.on(M, t.ondone) : this.on(M, (t => { this.emit("prefinish"), this.emit("finish"), this.emit("end"), this.emit("close") })), this.strict = !!t.strict, this.maxMetaEntrySize = t.maxMetaEntrySize || 1048576, this.filter = "function" == typeof t.filter ? t.filter : U, this.writable = !0, this.readable = !1, this[_] = new h, this[S] = null, this[p] = null, this[d] = null, this[u] = "begin", this[w] = "", this[y] = null, this[b] = null, this[R] = !1, this[T] = null, this[B] = !1, this[P] = !1, this[z] = !1, "function" == typeof t.onwarn && this.on("warn", t.onwarn), "function" == typeof t.onentry && this.on("entry", t.onentry) } [A](t, e) { let i; null === this[F] && (this[F] = !1); try { i = new r(t, e, this[y], this[b]) } catch (t) { return this.warn("TAR_ENTRY_INVALID", t) } if (i.nullBlock) this[P] ? (this[z] = !0, "begin" === this[u] && (this[u] = "header"), this[O]("eof")) : (this[P] = !0, this[O]("nullBlock")); else if (this[P] = !1, i.cksumValid) if (i.path) { const t = i.type; if (/^(Symbolic)?Link$/.test(t) && !i.linkpath) this.warn("TAR_ENTRY_INVALID", "linkpath required", { header: i }); else if (!/^(Symbolic)?Link$/.test(t) && i.linkpath) this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header: i }); else { const t = this[d] = new o(i, this[y], this[b]); if (!this[F]) if (t.remain) { const e = () => { t.invalid || (this[F] = !0) }; t.on("end", e) } else this[F] = !0; t.meta ? t.size > this.maxMetaEntrySize ? (t.ignore = !0, this[O]("ignoredEntry", t), this[u] = "ignore", t.resume()) : t.size > 0 && (this[w] = "", t.on("data", (t => this[w] += t)), this[u] = "meta") : (this[y] = null, t.ignore = t.ignore || !this.filter(t.path, t), t.ignore ? (this[O]("ignoredEntry", t), this[u] = t.remain ? "ignore" : "header", t.resume()) : (t.remain ? this[u] = "body" : (this[u] = "header", t.end()), this[p] ? this[_].push(t) : (this[_].push(t), this[m]()))) } } else this.warn("TAR_ENTRY_INVALID", "path is required", { header: i }); else this.warn("TAR_ENTRY_INVALID", "checksum failure", { header: i }) } [f](t) { let e = !0; return t ? Array.isArray(t) ? this.emit.apply(this, t) : (this[p] = t, this.emit("entry", t), t.emittedEnd || (t.on("end", (t => this[m]())), e = !1)) : (this[p] = null, e = !1), e } [m]() { do { } while (this[f](this[_].shift())); if (!this[_].length) { const t = this[p]; !t || t.flowing || t.size === t.remain ? this[C] || this.emit("drain") : t.once("drain", (t => this.emit("drain"))) } } [L](t, e) { const i = this[d], s = i.blockRemain, r = s >= t.length && 0 === e ? t : t.slice(e, e + s); return i.write(r), i.blockRemain || (this[u] = "header", this[d] = null, i.end()), r.length } [x](t, e) { const i = this[d], s = this[L](t, e); return this[d] || this[E](i), s } [O](t, e, i) { this[_].length || this[p] ? this[_].push([t, e, i]) : this.emit(t, e, i) } [E](t) { switch (this[O]("meta", this[w]), t.type) { case "ExtendedHeader": case "OldExtendedHeader": this[y] = l.parse(this[w], this[y], !1); break; case "GlobalExtendedHeader": this[b] = l.parse(this[w], this[b], !0); break; case "NextFileHasLongPath": case "OldGnuLongPath": this[y] = this[y] || Object.create(null), this[y].path = this[w].replace(/\0.*/, ""); break; case "NextFileHasLongLinkpath": this[y] = this[y] || Object.create(null), this[y].linkpath = this[w].replace(/\0.*/, ""); break; default: throw new Error("unknown meta: " + t.type) } } abort(t) { this[B] = !0, this.emit("abort", t), this.warn("TAR_ABORT", t, { recoverable: !1 }) } write(t) { if (this[B]) return; if (null === this[T] && t) { if (this[S] && (t = Buffer.concat([this[S], t]), this[S] = null), t.length < c.length) return this[S] = t, !0; for (let e = 0; null === this[T] && e < c.length; e++)t[e] !== c[e] && (this[T] = !1); if (null === this[T]) { const e = this[R]; this[R] = !1, this[T] = new a.Unzip, this[T].on("data", (t => this[v](t))), this[T].on("error", (t => this.abort(t))), this[T].on("end", (t => { this[R] = !0, this[v]() })), this[C] = !0; const i = this[T][e ? "end" : "write"](t); return this[C] = !1, i } } this[C] = !0, this[T] ? this[T].write(t) : this[v](t), this[C] = !1; const e = !this[_].length && (!this[p] || this[p].flowing); return e || this[_].length || this[p].once("drain", (t => this.emit("drain"))), e } [D](t) { t && !this[B] && (this[S] = this[S] ? Buffer.concat([this[S], t]) : t) } [N]() { if (this[R] && !this[g] && !this[B] && !this[I]) { this[g] = !0; const t = this[d]; if (t && t.blockRemain) { const e = this[S] ? this[S].length : 0; this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${t.blockRemain} more bytes, only ${e} available)`, { entry: t }), this[S] && t.write(this[S]), t.end() } this[O](M) } } [v](t) { if (this[I]) this[D](t); else if (t || this[S]) { if (this[I] = !0, this[S]) { this[D](t); const e = this[S]; this[S] = null, this[k](e) } else this[k](t); for (; this[S] && this[S].length >= 512 && !this[B] && !this[z];) { const t = this[S]; this[S] = null, this[k](t) } this[I] = !1 } else this[N](); this[S] && !this[R] || this[N]() } [k](t) { let e = 0; const i = t.length; for (; e + 512 <= i && !this[B] && !this[z];)switch (this[u]) { case "begin": case "header": this[A](t, e), e += 512; break; case "ignore": case "body": e += this[L](t, e); break; case "meta": e += this[x](t, e); break; default: throw new Error("invalid state: " + this[u]) }e < i && (this[S] ? this[S] = Buffer.concat([t.slice(e), this[S]]) : this[S] = t.slice(e)) } end(t) { this[B] || (this[T] ? this[T].end(t) : (this[R] = !0, this.write(t))) } }) }, 10: (t, e, i) => { const s = i(9491), r = i(1946), n = i(4922), { join: h } = i(1017), o = "win32" === (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform); t.exports = () => { const t = new Map, e = new Map, i = new Set, l = i => { const { paths: s, dirs: r } = (i => { const s = e.get(i); if (!s) throw new Error("function does not have any path reservations"); return { paths: s.paths.map((e => t.get(e))), dirs: [...s.dirs].map((e => t.get(e))) } })(i); return s.every((t => t[0] === i)) && r.every((t => t[0] instanceof Set && t[0].has(i))) }, a = t => !(i.has(t) || !l(t) || (i.add(t), t((() => c(t))), 0)), c = r => { if (!i.has(r)) return !1; const { paths: n, dirs: h } = e.get(r), o = new Set; return n.forEach((e => { const i = t.get(e); s.equal(i[0], r), 1 === i.length ? t.delete(e) : (i.shift(), "function" == typeof i[0] ? o.add(i[0]) : i[0].forEach((t => o.add(t)))) })), h.forEach((e => { const i = t.get(e); s(i[0] instanceof Set), 1 === i[0].size && 1 === i.length ? t.delete(e) : 1 === i[0].size ? (i.shift(), o.add(i[0])) : i[0].delete(r) })), i.delete(r), o.forEach((t => a(t))), !0 }; return { check: l, reserve: (i, s) => { i = o ? ["win32 parallelization disabled"] : i.map((t => r(n(h(t))).toLowerCase())); const l = new Set(i.map((t => (t => { const e = t.split("/").slice(0, -1).reduce(((t, e) => (t.length && (e = h(t[t.length - 1], e)), t.push(e || "/"), t)), []); return e })(t))).reduce(((t, e) => t.concat(e)))); return e.set(s, { dirs: l, paths: i }), i.forEach((e => { const i = t.get(e); i ? i.push(s) : t.set(e, [s]) })), l.forEach((e => { const i = t.get(e); i ? i[i.length - 1] instanceof Set ? i[i.length - 1].add(s) : i.push(new Set([s])) : t.set(e, [new Set([s])]) })), a(s) } } } }, 4747: (t, e, i) => { "use strict"; const s = i(7134), r = i(1017); class n { constructor(t, e) { this.atime = t.atime || null, this.charset = t.charset || null, this.comment = t.comment || null, this.ctime = t.ctime || null, this.gid = t.gid || null, this.gname = t.gname || null, this.linkpath = t.linkpath || null, this.mtime = t.mtime || null, this.path = t.path || null, this.size = t.size || null, this.uid = t.uid || null, this.uname = t.uname || null, this.dev = t.dev || null, this.ino = t.ino || null, this.nlink = t.nlink || null, this.global = e || !1 } encode() { const t = this.encodeBody(); if ("" === t) return null; const e = Buffer.byteLength(t), i = 512 * Math.ceil(1 + e / 512), n = Buffer.allocUnsafe(i); for (let t = 0; t < 512; t++)n[t] = 0; new s({ path: ("PaxHeader/" + r.basename(this.path)).slice(0, 99), mode: this.mode || 420, uid: this.uid || null, gid: this.gid || null, size: e, mtime: this.mtime || null, type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader", linkpath: "", uname: this.uname || "", gname: this.gname || "", devmaj: 0, devmin: 0, atime: this.atime || null, ctime: this.ctime || null }).encode(n), n.write(t, 512, e, "utf8"); for (let t = e + 512; t < n.length; t++)n[t] = 0; return n } encodeBody() { return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname") } encodeField(t) { if (null === this[t] || void 0 === this[t]) return ""; const e = " " + ("dev" === t || "ino" === t || "nlink" === t ? "SCHILY." : "") + t + "=" + (this[t] instanceof Date ? this[t].getTime() / 1e3 : this[t]) + "\n", i = Buffer.byteLength(e); let s = Math.floor(Math.log(i) / Math.log(10)) + 1; return i + s >= Math.pow(10, s) && (s += 1), s + i + e } } n.parse = (t, e, i) => new n(h(o(t), e), i); const h = (t, e) => e ? Object.keys(t).reduce(((e, i) => (e[i] = t[i], e)), e) : t, o = t => t.replace(/\n$/, "").split("\n").reduce(l, Object.create(null)), l = (t, e) => { const i = parseInt(e, 10); if (i !== Buffer.byteLength(e) + 1) return t; const s = (e = e.substr((i + " ").length)).split("="), r = s.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1"); if (!r) return t; const n = s.join("="); return t[r] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(r) ? new Date(1e3 * n) : /^[0-9]+$/.test(n) ? +n : n, t }; t.exports = n }, 6277: (t, e, i) => { "use strict"; const s = i(5736), r = i(2905), n = Symbol("slurp"); t.exports = class extends s { constructor(t, e, i) { switch (super(), this.pause(), this.extended = e, this.globalExtended = i, this.header = t, this.startBlockSize = 512 * Math.ceil(t.size / 512), this.blockRemain = this.startBlockSize, this.remain = t.size, this.type = t.type, this.meta = !1, this.ignore = !1, this.type) { case "File": case "OldFile": case "Link": case "SymbolicLink": case "CharacterDevice": case "BlockDevice": case "Directory": case "FIFO": case "ContiguousFile": case "GNUDumpDir": break; case "NextFileHasLongLinkpath": case "NextFileHasLongPath": case "OldGnuLongPath": case "GlobalExtendedHeader": case "ExtendedHeader": case "OldExtendedHeader": this.meta = !0; break; default: this.ignore = !0 }this.path = r(t.path), this.mode = t.mode, this.mode && (this.mode = 4095 & this.mode), this.uid = t.uid, this.gid = t.gid, this.uname = t.uname, this.gname = t.gname, this.size = t.size, this.mtime = t.mtime, this.atime = t.atime, this.ctime = t.ctime, this.linkpath = r(t.linkpath), this.uname = t.uname, this.gname = t.gname, e && this[n](e), i && this[n](i, !0) } write(t) { const e = t.length; if (e > this.blockRemain) throw new Error("writing more to entry than is appropriate"); const i = this.remain, s = this.blockRemain; return this.remain = Math.max(0, i - e), this.blockRemain = Math.max(0, s - e), !!this.ignore || (i >= e ? super.write(t) : super.write(t.slice(0, i))) } [n](t, e) { for (const i in t) null === t[i] || void 0 === t[i] || e && "path" === i || (this[i] = "path" === i || "linkpath" === i ? r(t[i]) : t[i]) } } }, 1746: (t, e, i) => { "use strict"; const s = i(2093), r = i(8042), n = i(7147), h = i(292), o = i(6473), l = i(1017), a = i(7134); t.exports = (t, e, i) => { const r = s(t); if (!r.file) throw new TypeError("file is required"); if (r.gzip) throw new TypeError("cannot append to compressed archives"); if (!e || !Array.isArray(e) || !e.length) throw new TypeError("no files or directories specified"); return e = Array.from(e), r.sync ? c(r, e) : d(r, e, i) }; const c = (t, e) => { const i = new r.Sync(t); let s, h, o = !0; try { try { s = n.openSync(t.file, "r+") } catch (e) { if ("ENOENT" !== e.code) throw e; s = n.openSync(t.file, "w+") } const r = n.fstatSync(s), l = Buffer.alloc(512); t: for (h = 0; h < r.size; h += 512) { for (let t = 0, e = 0; t < 512; t += e) { if (e = n.readSync(s, l, t, l.length - t, h + t), 0 === h && 31 === l[0] && 139 === l[1]) throw new Error("cannot append to compressed archives"); if (!e) break t } const e = new a(l); if (!e.cksumValid) break; const i = 512 * Math.ceil(e.size / 512); if (h + i + 512 > r.size) break; h += i, t.mtimeCache && t.mtimeCache.set(e.path, e.mtime) } o = !1, u(t, i, h, s, e) } finally { if (o) try { n.closeSync(s) } catch (t) { } } }, u = (t, e, i, s, r) => { const n = new h.WriteStreamSync(t.file, { fd: s, start: i }); e.pipe(n), p(e, r) }, d = (t, e, i) => { e = Array.from(e); const s = new r(t), o = new Promise(((i, r) => { s.on("error", r); let o = "r+"; const l = (c, u) => c && "ENOENT" === c.code && "r+" === o ? (o = "w+", n.open(t.file, o, l)) : c ? r(c) : void n.fstat(u, ((o, l) => { if (o) return n.close(u, (() => r(o))); ((e, i, s) => { const r = (t, i) => { t ? n.close(e, (e => s(t))) : s(null, i) }; let h = 0; if (0 === i) return r(null, 0); let o = 0; const l = Buffer.alloc(512), c = (s, u) => { if (s) return r(s); if (o += u, o < 512 && u) return n.read(e, l, o, l.length - o, h + o, c); if (0 === h && 31 === l[0] && 139 === l[1]) return r(new Error("cannot append to compressed archives")); if (o < 512) return r(null, h); const d = new a(l); if (!d.cksumValid) return r(null, h); const p = 512 * Math.ceil(d.size / 512); return h + p + 512 > i ? r(null, h) : (h += p + 512, h >= i ? r(null, h) : (t.mtimeCache && t.mtimeCache.set(d.path, d.mtime), o = 0, void n.read(e, l, 0, 512, h, c))) }; n.read(e, l, 0, 512, h, c) })(u, l.size, ((n, o) => { if (n) return r(n); const l = new h.WriteStream(t.file, { fd: u, start: o }); s.pipe(l), l.on("error", r), l.on("close", i), m(s, e) })) })); n.open(t.file, o, l) })); return i ? o.then(i, i) : o }, p = (t, e) => { e.forEach((e => { "@" === e.charAt(0) ? o({ file: l.resolve(t.cwd, e.substr(1)), sync: !0, noResume: !0, onentry: e => t.add(e) }) : t.add(e) })), t.end() }, m = (t, e) => { for (; e.length;) { const i = e.shift(); if ("@" === i.charAt(0)) return o({ file: l.resolve(t.cwd, i.substr(1)), noResume: !0, onentry: e => t.add(e) }).then((i => m(t, e))); t.add(i) } t.end() } }, 2214: (t, e, i) => { const { isAbsolute: s, parse: r } = i(1017).win32; t.exports = t => { let e = "", i = r(t); for (; s(t) || i.root;) { const s = "/" === t.charAt(0) && "//?/" !== t.slice(0, 4) ? "/" : i.root; t = t.substr(s.length), e += s, i = r(t) } return [e, t] } }, 4922: t => { t.exports = t => { let e = t.length - 1, i = -1; for (; e > -1 && "/" === t.charAt(e);)i = e, e--; return -1 === i ? t : t.slice(0, i) } }, 4402: (t, e) => { "use strict"; e.name = new Map([["0", "File"], ["", "OldFile"], ["1", "Link"], ["2", "SymbolicLink"], ["3", "CharacterDevice"], ["4", "BlockDevice"], ["5", "Directory"], ["6", "FIFO"], ["7", "ContiguousFile"], ["g", "GlobalExtendedHeader"], ["x", "ExtendedHeader"], ["A", "SolarisACL"], ["D", "GNUDumpDir"], ["I", "Inode"], ["K", "NextFileHasLongLinkpath"], ["L", "NextFileHasLongPath"], ["M", "ContinuationFile"], ["N", "OldGnuLongPath"], ["S", "SparseFile"], ["V", "TapeVolumeHeader"], ["X", "OldExtendedHeader"]]), e.code = new Map(Array.from(e.name).map((t => [t[1], t[0]]))) }, 2699: (t, e, i) => { "use strict"; const s = i(9491), r = i(6824), n = i(7147), h = i(292), o = i(1017), l = i(3248), a = i(619), c = i(10), u = i(2214), d = i(2905), p = i(4922), m = i(1946), f = Symbol("onEntry"), y = Symbol("checkFs"), b = Symbol("checkFs2"), w = Symbol("pruneCache"), E = Symbol("isReusable"), S = Symbol("makeFs"), _ = Symbol("file"), R = Symbol("directory"), g = Symbol("link"), O = Symbol("symlink"), T = Symbol("hardlink"), v = Symbol("unsupported"), k = Symbol("checkPath"), L = Symbol("mkdir"), x = Symbol("onError"), A = Symbol("pending"), I = Symbol("pend"), D = Symbol("unpend"), N = Symbol("ended"), C = Symbol("maybeClose"), B = Symbol("skip"), M = Symbol("doChown"), F = Symbol("uid"), P = Symbol("gid"), z = Symbol("checkedCwd"), U = i(6113), j = i(5879), G = "win32" === (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform), H = (t, e, i) => t === t >>> 0 ? t : e === e >>> 0 ? e : i, Z = t => m(p(d(t))).toLowerCase(); class W extends r { constructor(t) { if (t || (t = {}), t.ondone = t => { this[N] = !0, this[C]() }, super(t), this[z] = !1, this.reservations = c(), this.transform = "function" == typeof t.transform ? t.transform : null, this.writable = !0, this.readable = !1, this[A] = 0, this[N] = !1, this.dirCache = t.dirCache || new Map, "number" == typeof t.uid || "number" == typeof t.gid) { if ("number" != typeof t.uid || "number" != typeof t.gid) throw new TypeError("cannot set owner without number uid and gid"); if (t.preserveOwner) throw new TypeError("cannot preserve owner in archive and also set owner explicitly"); this.uid = t.uid, this.gid = t.gid, this.setOwner = !0 } else this.uid = null, this.gid = null, this.setOwner = !1; void 0 === t.preserveOwner && "number" != typeof t.uid ? this.preserveOwner = process.getuid && 0 === process.getuid() : this.preserveOwner = !!t.preserveOwner, this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null, this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null, this.forceChown = !0 === t.forceChown, this.win32 = !!t.win32 || G, this.newer = !!t.newer, this.keep = !!t.keep, this.noMtime = !!t.noMtime, this.preservePaths = !!t.preservePaths, this.unlink = !!t.unlink, this.cwd = d(o.resolve(t.cwd || process.cwd())), this.strip = +t.strip || 0, this.processUmask = t.noChmod ? 0 : process.umask(), this.umask = "number" == typeof t.umask ? t.umask : this.processUmask, this.dmode = t.dmode || 511 & ~this.umask, this.fmode = t.fmode || 438 & ~this.umask, this.on("entry", (t => this[f](t))) } warn(t, e, i = {}) { return "TAR_BAD_ARCHIVE" !== t && "TAR_ABORT" !== t || (i.recoverable = !1), super.warn(t, e, i) } [C]() { this[N] && 0 === this[A] && (this.emit("prefinish"), this.emit("finish"), this.emit("end"), this.emit("close")) } [k](t) { if (this.strip) { const e = d(t.path).split("/"); if (e.length < this.strip) return !1; if (t.path = e.slice(this.strip).join("/"), "Link" === t.type) { const e = d(t.linkpath).split("/"); if (!(e.length >= this.strip)) return !1; t.linkpath = e.slice(this.strip).join("/") } } if (!this.preservePaths) { const e = d(t.path), i = e.split("/"); if (i.includes("..") || G && /^[a-z]:\.\.$/i.test(i[0])) return this.warn("TAR_ENTRY_ERROR", "path contains '..'", { entry: t, path: e }), !1; const [s, r] = u(e); s && (t.path = r, this.warn("TAR_ENTRY_INFO", `stripping ${s} from absolute path`, { entry: t, path: e })) } if (o.isAbsolute(t.path) ? t.absolute = d(o.resolve(t.path)) : t.absolute = d(o.resolve(this.cwd, t.path)), !this.preservePaths && 0 !== t.absolute.indexOf(this.cwd + "/") && t.absolute !== this.cwd) return this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", { entry: t, path: d(t.path), resolvedPath: t.absolute, cwd: this.cwd }), !1; if (t.absolute === this.cwd && "Directory" !== t.type && "GNUDumpDir" !== t.type) return !1; if (this.win32) { const { root: e } = o.win32.parse(t.absolute); t.absolute = e + a.encode(t.absolute.substr(e.length)); const { root: i } = o.win32.parse(t.path); t.path = i + a.encode(t.path.substr(i.length)) } return !0 } [f](t) { if (!this[k](t)) return t.resume(); switch (s.equal(typeof t.absolute, "string"), t.type) { case "Directory": case "GNUDumpDir": t.mode && (t.mode = 448 | t.mode); case "File": case "OldFile": case "ContiguousFile": case "Link": case "SymbolicLink": return this[y](t); default: return this[v](t) } } [x](t, e) { "CwdError" === t.name ? this.emit("error", t) : (this.warn("TAR_ENTRY_ERROR", t, { entry: e }), this[D](), e.resume()) } [L](t, e, i) { l(d(t), { uid: this.uid, gid: this.gid, processUid: this.processUid, processGid: this.processGid, umask: this.processUmask, preserve: this.preservePaths, unlink: this.unlink, cache: this.dirCache, cwd: this.cwd, mode: e, noChmod: this.noChmod }, i) } [M](t) { return this.forceChown || this.preserveOwner && ("number" == typeof t.uid && t.uid !== this.processUid || "number" == typeof t.gid && t.gid !== this.processGid) || "number" == typeof this.uid && this.uid !== this.processUid || "number" == typeof this.gid && this.gid !== this.processGid } [F](t) { return H(this.uid, t.uid, this.processUid) } [P](t) { return H(this.gid, t.gid, this.processGid) } [_](t, e) { const i = 4095 & t.mode || this.fmode, s = new h.WriteStream(t.absolute, { flags: j(t.size), mode: i, autoClose: !1 }); s.on("error", (i => { s.fd && n.close(s.fd, (() => { })), s.write = () => !0, this[x](i, t), e() })); let r = 1; const o = i => { if (i) return s.fd && n.close(s.fd, (() => { })), this[x](i, t), void e(); 0 == --r && n.close(s.fd, (i => { i ? this[x](i, t) : this[D](), e() })) }; s.on("finish", (e => { const i = t.absolute, h = s.fd; if (t.mtime && !this.noMtime) { r++; const e = t.atime || new Date, s = t.mtime; n.futimes(h, e, s, (t => t ? n.utimes(i, e, s, (e => o(e && t))) : o())) } if (this[M](t)) { r++; const e = this[F](t), s = this[P](t); n.fchown(h, e, s, (t => t ? n.chown(i, e, s, (e => o(e && t))) : o())) } o() })); const l = this.transform && this.transform(t) || t; l !== t && (l.on("error", (i => { this[x](i, t), e() })), t.pipe(l)), l.pipe(s) } [R](t, e) { const i = 4095 & t.mode || this.dmode; this[L](t.absolute, i, (i => { if (i) return this[x](i, t), void e(); let s = 1; const r = i => { 0 == --s && (e(), this[D](), t.resume()) }; t.mtime && !this.noMtime && (s++, n.utimes(t.absolute, t.atime || new Date, t.mtime, r)), this[M](t) && (s++, n.chown(t.absolute, this[F](t), this[P](t), r)), r() })) } [v](t) { t.unsupported = !0, this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${t.type}`, { entry: t }), t.resume() } [O](t, e) { this[g](t, t.linkpath, "symlink", e) } [T](t, e) { const i = d(o.resolve(this.cwd, t.linkpath)); this[g](t, i, "link", e) } [I]() { this[A]++ } [D]() { this[A]--, this[C]() } [B](t) { this[D](), t.resume() } [E](t, e) { return "File" === t.type && !this.unlink && e.isFile() && e.nlink <= 1 && !G } [y](t) { this[I](); const e = [t.path]; t.linkpath && e.push(t.linkpath), this.reservations.reserve(e, (e => this[b](t, e))) } [w](t) { "SymbolicLink" === t.type ? (t => { for (const e of t.keys()) t.delete(e) })(this.dirCache) : "Directory" !== t.type && ((t, e) => { e = Z(e); for (const i of t.keys()) { const s = Z(i); s !== e && 0 !== s.indexOf(e + "/") || t.delete(i) } })(this.dirCache, t.absolute) } [b](t, e) { this[w](t); const i = i => { this[w](t), e(i) }, s = () => { if (t.absolute !== this.cwd) { const e = d(o.dirname(t.absolute)); if (e !== this.cwd) return this[L](e, this.dmode, (e => { if (e) return this[x](e, t), void i(); r() })) } r() }, r = () => { n.lstat(t.absolute, ((e, s) => { if (s && (this.keep || this.newer && s.mtime > t.mtime)) return this[B](t), void i(); if (e || this[E](t, s)) return this[S](null, t, i); if (s.isDirectory()) { if ("Directory" === t.type) { const e = e => this[S](e, t, i); return !this.noChmod && t.mode && (4095 & s.mode) !== t.mode ? n.chmod(t.absolute, t.mode, e) : e() } if (t.absolute !== this.cwd) return n.rmdir(t.absolute, (e => this[S](e, t, i))) } if (t.absolute === this.cwd) return this[S](null, t, i); ((t, e) => { if (!G) return n.unlink(t, e); const i = t + ".DELETE." + U.randomBytes(16).toString("hex"); n.rename(t, i, (t => { if (t) return e(t); n.unlink(i, e) })) })(t.absolute, (e => this[S](e, t, i))) })) }; this[z] ? s() : (() => { this[L](this.cwd, this.dmode, (e => { if (e) return this[x](e, t), void i(); this[z] = !0, s() })) })() } [S](t, e, i) { if (t) return this[x](t, e), void i(); switch (e.type) { case "File": case "OldFile": case "ContiguousFile": return this[_](e, i); case "Link": return this[T](e, i); case "SymbolicLink": return this[O](e, i); case "Directory": case "GNUDumpDir": return this[R](e, i) } } [g](t, e, i, s) { n[i](e, t.absolute, (e => { e ? this[x](e, t) : (this[D](), t.resume()), s() })) } } const V = t => { try { return [null, t()] } catch (t) { return [t, null] } }; W.Sync = class extends W { [S](t, e) { return super[S](t, e, (() => { })) } [y](t) { if (this[w](t), !this[z]) { const e = this[L](this.cwd, this.dmode); if (e) return this[x](e, t); this[z] = !0 } if (t.absolute !== this.cwd) { const e = d(o.dirname(t.absolute)); if (e !== this.cwd) { const i = this[L](e, this.dmode); if (i) return this[x](i, t) } } const [e, i] = V((() => n.lstatSync(t.absolute))); if (i && (this.keep || this.newer && i.mtime > t.mtime)) return this[B](t); if (e || this[E](t, i)) return this[S](null, t); if (i.isDirectory()) { if ("Directory" === t.type) { const e = !this.noChmod && t.mode && (4095 & i.mode) !== t.mode, [s] = e ? V((() => { n.chmodSync(t.absolute, t.mode) })) : []; return this[S](s, t) } const [e] = V((() => n.rmdirSync(t.absolute))); this[S](e, t) } const [s] = t.absolute === this.cwd ? [] : V((() => (t => { if (!G) return n.unlinkSync(t); const e = t + ".DELETE." + U.randomBytes(16).toString("hex"); n.renameSync(t, e), n.unlinkSync(e) })(t.absolute))); this[S](s, t) } [_](t, e) { const i = 4095 & t.mode || this.fmode, s = i => { let s; try { n.closeSync(r) } catch (t) { s = t } (i || s) && this[x](i || s, t), e() }; let r; try { r = n.openSync(t.absolute, j(t.size), i) } catch (t) { return s(t) } const h = this.transform && this.transform(t) || t; h !== t && (h.on("error", (e => this[x](e, t))), t.pipe(h)), h.on("data", (t => { try { n.writeSync(r, t, 0, t.length) } catch (t) { s(t) } })), h.on("end", (e => { let i = null; if (t.mtime && !this.noMtime) { const e = t.atime || new Date, s = t.mtime; try { n.futimesSync(r, e, s) } catch (r) { try { n.utimesSync(t.absolute, e, s) } catch (t) { i = r } } } if (this[M](t)) { const e = this[F](t), s = this[P](t); try { n.fchownSync(r, e, s) } catch (r) { try { n.chownSync(t.absolute, e, s) } catch (t) { i = i || r } } } s(i) })) } [R](t, e) { const i = 4095 & t.mode || this.dmode, s = this[L](t.absolute, i); if (s) return this[x](s, t), void e(); if (t.mtime && !this.noMtime) try { n.utimesSync(t.absolute, t.atime || new Date, t.mtime) } catch (s) { } if (this[M](t)) try { n.chownSync(t.absolute, this[F](t), this[P](t)) } catch (s) { } e(), t.resume() } [L](t, e) { try { return l.sync(d(t), { uid: this.uid, gid: this.gid, processUid: this.processUid, processGid: this.processGid, umask: this.processUmask, preserve: this.preservePaths, unlink: this.unlink, cache: this.dirCache, cwd: this.cwd, mode: e }) } catch (t) { return t } } [g](t, e, i, s) { try { n[i + "Sync"](e, t.absolute), s(), t.resume() } catch (e) { return this[x](e, t) } } }, t.exports = W }, 5997: (t, e, i) => { "use strict"; const s = i(2093), r = i(1746); t.exports = (t, e, i) => { const h = s(t); if (!h.file) throw new TypeError("file is required"); if (h.gzip) throw new TypeError("cannot append to compressed archives"); if (!e || !Array.isArray(e) || !e.length) throw new TypeError("no files or directories specified"); return e = Array.from(e), n(h), r(h, e, i) }; const n = t => { const e = t.filter; t.mtimeCache || (t.mtimeCache = new Map), t.filter = e ? (i, s) => e(i, s) && !(t.mtimeCache.get(i) > s.mtime) : (e, i) => !(t.mtimeCache.get(e) > i.mtime) } }, 7902: t => { "use strict"; t.exports = t => class extends t { warn(t, e, i = {}) { this.file && (i.file = this.file), this.cwd && (i.cwd = this.cwd), i.code = e instanceof Error && e.code || t, i.tarCode = t, this.strict || !1 === i.recoverable ? e instanceof Error ? this.emit("error", Object.assign(e, i)) : this.emit("error", Object.assign(new Error(`${t}: ${e}`), i)) : (e instanceof Error && (i = Object.assign(e, i), e = e.message), this.emit("warn", i.tarCode, e, i)) } } }, 619: t => { "use strict"; const e = ["|", "<", ">", "?", ":"], i = e.map((t => String.fromCharCode(61440 + t.charCodeAt(0)))), s = new Map(e.map(((t, e) => [t, i[e]]))), r = new Map(i.map(((t, i) => [t, e[i]]))); t.exports = { encode: t => e.reduce(((t, e) => t.split(e).join(s.get(e))), t), decode: t => i.reduce(((t, e) => t.split(e).join(r.get(e))), t) } }, 7620: (t, e, i) => { "use strict"; const s = i(5736), r = i(4747), n = i(7134), h = i(7147), o = i(1017), l = i(2905), a = i(4922), c = (t, e) => e ? (t = l(t).replace(/^\.(\/|$)/, ""), a(e) + "/" + t) : l(t), u = Symbol("process"), d = Symbol("file"), p = Symbol("directory"), m = Symbol("symlink"), f = Symbol("hardlink"), y = Symbol("header"), b = Symbol("read"), w = Symbol("lstat"), E = Symbol("onlstat"), S = Symbol("onread"), _ = Symbol("onreadlink"), R = Symbol("openfile"), g = Symbol("onopenfile"), O = Symbol("close"), T = Symbol("mode"), v = Symbol("awaitDrain"), k = Symbol("ondrain"), L = Symbol("prefix"), x = Symbol("hadError"), A = i(7902), I = i(619), D = i(2214), N = i(7716), C = A(class extends s { constructor(t, e) { if (super(e = e || {}), "string" != typeof t) throw new TypeError("path is required"); this.path = l(t), this.portable = !!e.portable, this.myuid = process.getuid && process.getuid() || 0, this.myuser = process.env.USER || "", this.maxReadSize = e.maxReadSize || 16777216, this.linkCache = e.linkCache || new Map, this.statCache = e.statCache || new Map, this.preservePaths = !!e.preservePaths, this.cwd = l(e.cwd || process.cwd()), this.strict = !!e.strict, this.noPax = !!e.noPax, this.noMtime = !!e.noMtime, this.mtime = e.mtime || null, this.prefix = e.prefix ? l(e.prefix) : null, this.fd = null, this.blockLen = null, this.blockRemain = null, this.buf = null, this.offset = null, this.length = null, this.pos = null, this.remain = null, "function" == typeof e.onwarn && this.on("warn", e.onwarn); let i = !1; if (!this.preservePaths) { const [t, e] = D(this.path); t && (this.path = e, i = t) } this.win32 = !!e.win32 || "win32" === process.platform, this.win32 && (this.path = I.decode(this.path.replace(/\\/g, "/")), t = t.replace(/\\/g, "/")), this.absolute = l(e.absolute || o.resolve(this.cwd, t)), "" === this.path && (this.path = "./"), i && this.warn("TAR_ENTRY_INFO", `stripping ${i} from absolute path`, { entry: this, path: i + this.path }), this.statCache.has(this.absolute) ? this[E](this.statCache.get(this.absolute)) : this[w]() } emit(t, ...e) { return "error" === t && (this[x] = !0), super.emit(t, ...e) } [w]() { h.lstat(this.absolute, ((t, e) => { if (t) return this.emit("error", t); this[E](e) })) } [E](t) { this.statCache.set(this.absolute, t), this.stat = t, t.isFile() || (t.size = 0), this.type = M(t), this.emit("stat", t), this[u]() } [u]() { switch (this.type) { case "File": return this[d](); case "Directory": return this[p](); case "SymbolicLink": return this[m](); default: return this.end() } } [T](t) { return N(t, "Directory" === this.type, this.portable) } [L](t) { return c(t, this.prefix) } [y]() { "Directory" === this.type && this.portable && (this.noMtime = !0), this.header = new n({ path: this[L](this.path), linkpath: "Link" === this.type ? this[L](this.linkpath) : this.linkpath, mode: this[T](this.stat.mode), uid: this.portable ? null : this.stat.uid, gid: this.portable ? null : this.stat.gid, size: this.stat.size, mtime: this.noMtime ? null : this.mtime || this.stat.mtime, type: this.type, uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "", atime: this.portable ? null : this.stat.atime, ctime: this.portable ? null : this.stat.ctime }), this.header.encode() && !this.noPax && super.write(new r({ atime: this.portable ? null : this.header.atime, ctime: this.portable ? null : this.header.ctime, gid: this.portable ? null : this.header.gid, mtime: this.noMtime ? null : this.mtime || this.header.mtime, path: this[L](this.path), linkpath: "Link" === this.type ? this[L](this.linkpath) : this.linkpath, size: this.header.size, uid: this.portable ? null : this.header.uid, uname: this.portable ? null : this.header.uname, dev: this.portable ? null : this.stat.dev, ino: this.portable ? null : this.stat.ino, nlink: this.portable ? null : this.stat.nlink }).encode()), super.write(this.header.block) } [p]() { "/" !== this.path.substr(-1) && (this.path += "/"), this.stat.size = 0, this[y](), this.end() } [m]() { h.readlink(this.absolute, ((t, e) => { if (t) return this.emit("error", t); this[_](e) })) } [_](t) { this.linkpath = l(t), this[y](), this.end() } [f](t) { this.type = "Link", this.linkpath = l(o.relative(this.cwd, t)), this.stat.size = 0, this[y](), this.end() } [d]() { if (this.stat.nlink > 1) { const t = this.stat.dev + ":" + this.stat.ino; if (this.linkCache.has(t)) { const e = this.linkCache.get(t); if (0 === e.indexOf(this.cwd)) return this[f](e) } this.linkCache.set(t, this.absolute) } if (this[y](), 0 === this.stat.size) return this.end(); this[R]() } [R]() { h.open(this.absolute, "r", ((t, e) => { if (t) return this.emit("error", t); this[g](e) })) } [g](t) { if (this.fd = t, this[x]) return this[O](); this.blockLen = 512 * Math.ceil(this.stat.size / 512), this.blockRemain = this.blockLen; const e = Math.min(this.blockLen, this.maxReadSize); this.buf = Buffer.allocUnsafe(e), this.offset = 0, this.pos = 0, this.remain = this.stat.size, this.length = this.buf.length, this[b]() } [b]() { const { fd: t, buf: e, offset: i, length: s, pos: r } = this; h.read(t, e, i, s, r, ((t, e) => { if (t) return this[O]((() => this.emit("error", t))); this[S](e) })) } [O](t) { h.close(this.fd, t) } [S](t) { if (t <= 0 && this.remain > 0) { const t = new Error("encountered unexpected EOF"); return t.path = this.absolute, t.syscall = "read", t.code = "EOF", this[O]((() => this.emit("error", t))) } if (t > this.remain) { const t = new Error("did not encounter expected EOF"); return t.path = this.absolute, t.syscall = "read", t.code = "EOF", this[O]((() => this.emit("error", t))) } if (t === this.remain) for (let e = t; e < this.length && t < this.blockRemain; e++)this.buf[e + this.offset] = 0, t++, this.remain++; const e = 0 === this.offset && t === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + t); this.write(e) ? this[k]() : this[v]((() => this[k]())) } [v](t) { this.once("drain", t) } write(t) { if (this.blockRemain < t.length) { const t = new Error("writing more data than expected"); return t.path = this.absolute, this.emit("error", t) } return this.remain -= t.length, this.blockRemain -= t.length, this.pos += t.length, this.offset += t.length, super.write(t) } [k]() { if (!this.remain) return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), this[O]((t => t ? this.emit("error", t) : this.end())); this.offset >= this.length && (this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length)), this.offset = 0), this.length = this.buf.length - this.offset, this[b]() } }), B = A(class extends s { constructor(t, e) { super(e = e || {}), this.preservePaths = !!e.preservePaths, this.portable = !!e.portable, this.strict = !!e.strict, this.noPax = !!e.noPax, this.noMtime = !!e.noMtime, this.readEntry = t, this.type = t.type, "Directory" === this.type && this.portable && (this.noMtime = !0), this.prefix = e.prefix || null, this.path = l(t.path), this.mode = this[T](t.mode), this.uid = this.portable ? null : t.uid, this.gid = this.portable ? null : t.gid, this.uname = this.portable ? null : t.uname, this.gname = this.portable ? null : t.gname, this.size = t.size, this.mtime = this.noMtime ? null : e.mtime || t.mtime, this.atime = this.portable ? null : t.atime, this.ctime = this.portable ? null : t.ctime, this.linkpath = l(t.linkpath), "function" == typeof e.onwarn && this.on("warn", e.onwarn); let i = !1; if (!this.preservePaths) { const [t, e] = D(this.path); t && (this.path = e, i = t) } this.remain = t.size, this.blockRemain = t.startBlockSize, this.header = new n({ path: this[L](this.path), linkpath: "Link" === this.type ? this[L](this.linkpath) : this.linkpath, mode: this.mode, uid: this.portable ? null : this.uid, gid: this.portable ? null : this.gid, size: this.size, mtime: this.noMtime ? null : this.mtime, type: this.type, uname: this.portable ? null : this.uname, atime: this.portable ? null : this.atime, ctime: this.portable ? null : this.ctime }), i && this.warn("TAR_ENTRY_INFO", `stripping ${i} from absolute path`, { entry: this, path: i + this.path }), this.header.encode() && !this.noPax && super.write(new r({ atime: this.portable ? null : this.atime, ctime: this.portable ? null : this.ctime, gid: this.portable ? null : this.gid, mtime: this.noMtime ? null : this.mtime, path: this[L](this.path), linkpath: "Link" === this.type ? this[L](this.linkpath) : this.linkpath, size: this.size, uid: this.portable ? null : this.uid, uname: this.portable ? null : this.uname, dev: this.portable ? null : this.readEntry.dev, ino: this.portable ? null : this.readEntry.ino, nlink: this.portable ? null : this.readEntry.nlink }).encode()), super.write(this.header.block), t.pipe(this) } [L](t) { return c(t, this.prefix) } [T](t) { return N(t, "Directory" === this.type, this.portable) } write(t) { const e = t.length; if (e > this.blockRemain) throw new Error("writing more to entry than is appropriate"); return this.blockRemain -= e, super.write(t) } end() { return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), super.end() } }); C.Sync = class extends C { [w]() { this[E](h.lstatSync(this.absolute)) } [m]() { this[_](h.readlinkSync(this.absolute)) } [R]() { this[g](h.openSync(this.absolute, "r")) } [b]() { let t = !0; try { const { fd: e, buf: i, offset: s, length: r, pos: n } = this, o = h.readSync(e, i, s, r, n); this[S](o), t = !1 } finally { if (t) try { this[O]((() => { })) } catch (t) { } } } [v](t) { t() } [O](t) { h.closeSync(this.fd), t() } }, C.Tar = B; const M = t => t.isFile() ? "File" : t.isDirectory() ? "Directory" : t.isSymbolicLink() ? "SymbolicLink" : "Unsupported"; t.exports = C }, 9602: t => { "use strict"; t.exports = function (t) { t.prototype[Symbol.iterator] = function* () { for (let t = this.head; t; t = t.next)yield t.value } } }, 4411: (t, e, i) => { "use strict"; function s(t) { var e = this; if (e instanceof s || (e = new s), e.tail = null, e.head = null, e.length = 0, t && "function" == typeof t.forEach) t.forEach((function (t) { e.push(t) })); else if (arguments.length > 0) for (var i = 0, r = arguments.length; i < r; i++)e.push(arguments[i]); return e } function r(t, e) { t.tail = new h(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++ } function n(t, e) { t.head = new h(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++ } function h(t, e, i, s) { if (!(this instanceof h)) return new h(t, e, i, s); this.list = s, this.value = t, e ? (e.next = this, this.prev = e) : this.prev = null, i ? (i.prev = this, this.next = i) : this.next = null } t.exports = s, s.Node = h, s.create = s, s.prototype.removeNode = function (t) { if (t.list !== this) throw new Error("removing node which does not belong to this list"); var e = t.next, i = t.prev; return e && (e.prev = i), i && (i.next = e), t === this.head && (this.head = e), t === this.tail && (this.tail = i), t.list.length--, t.next = null, t.prev = null, t.list = null, e }, s.prototype.unshiftNode = function (t) { if (t !== this.head) { t.list && t.list.removeNode(t); var e = this.head; t.list = this, t.next = e, e && (e.prev = t), this.head = t, this.tail || (this.tail = t), this.length++ } }, s.prototype.pushNode = function (t) { if (t !== this.tail) { t.list && t.list.removeNode(t); var e = this.tail; t.list = this, t.prev = e, e && (e.next = t), this.tail = t, this.head || (this.head = t), this.length++ } }, s.prototype.push = function () { for (var t = 0, e = arguments.length; t < e; t++)r(this, arguments[t]); return this.length }, s.prototype.unshift = function () { for (var t = 0, e = arguments.length; t < e; t++)n(this, arguments[t]); return this.length }, s.prototype.pop = function () { if (this.tail) { var t = this.tail.value; return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t } }, s.prototype.shift = function () { if (this.head) { var t = this.head.value; return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t } }, s.prototype.forEach = function (t, e) { e = e || this; for (var i = this.head, s = 0; null !== i; s++)t.call(e, i.value, s, this), i = i.next }, s.prototype.forEachReverse = function (t, e) { e = e || this; for (var i = this.tail, s = this.length - 1; null !== i; s--)t.call(e, i.value, s, this), i = i.prev }, s.prototype.get = function (t) { for (var e = 0, i = this.head; null !== i && e < t; e++)i = i.next; if (e === t && null !== i) return i.value }, s.prototype.getReverse = function (t) { for (var e = 0, i = this.tail; null !== i && e < t; e++)i = i.prev; if (e === t && null !== i) return i.value }, s.prototype.map = function (t, e) { e = e || this; for (var i = new s, r = this.head; null !== r;)i.push(t.call(e, r.value, this)), r = r.next; return i }, s.prototype.mapReverse = function (t, e) { e = e || this; for (var i = new s, r = this.tail; null !== r;)i.push(t.call(e, r.value, this)), r = r.prev; return i }, s.prototype.reduce = function (t, e) { var i, s = this.head; if (arguments.length > 1) i = e; else { if (!this.head) throw new TypeError("Reduce of empty list with no initial value"); s = this.head.next, i = this.head.value } for (var r = 0; null !== s; r++)i = t(i, s.value, r), s = s.next; return i }, s.prototype.reduceReverse = function (t, e) { var i, s = this.tail; if (arguments.length > 1) i = e; else { if (!this.tail) throw new TypeError("Reduce of empty list with no initial value"); s = this.tail.prev, i = this.tail.value } for (var r = this.length - 1; null !== s; r--)i = t(i, s.value, r), s = s.prev; return i }, s.prototype.toArray = function () { for (var t = new Array(this.length), e = 0, i = this.head; null !== i; e++)t[e] = i.value, i = i.next; return t }, s.prototype.toArrayReverse = function () { for (var t = new Array(this.length), e = 0, i = this.tail; null !== i; e++)t[e] = i.value, i = i.prev; return t }, s.prototype.slice = function (t, e) { (e = e || this.length) < 0 && (e += this.length), (t = t || 0) < 0 && (t += this.length); var i = new s; if (e < t || e < 0) return i; t < 0 && (t = 0), e > this.length && (e = this.length); for (var r = 0, n = this.head; null !== n && r < t; r++)n = n.next; for (; null !== n && r < e; r++, n = n.next)i.push(n.value); return i }, s.prototype.sliceReverse = function (t, e) { (e = e || this.length) < 0 && (e += this.length), (t = t || 0) < 0 && (t += this.length); var i = new s; if (e < t || e < 0) return i; t < 0 && (t = 0), e > this.length && (e = this.length); for (var r = this.length, n = this.tail; null !== n && r > e; r--)n = n.prev; for (; null !== n && r > t; r--, n = n.prev)i.push(n.value); return i }, s.prototype.splice = function (t, e, ...i) { t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t); for (var s = 0, r = this.head; null !== r && s < t; s++)r = r.next; var n, o, l, a, c = []; for (s = 0; r && s < e; s++)c.push(r.value), r = this.removeNode(r); for (null === r && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev), s = 0; s < i.length; s++)n = this, o = r, l = i[s], a = void 0, null === (a = o === n.head ? new h(l, null, o, n) : new h(l, o, o.next, n)).next && (n.tail = a), null === a.prev && (n.head = a), n.length++, r = a; return c }, s.prototype.reverse = function () { for (var t = this.head, e = this.tail, i = t; null !== i; i = i.prev) { var s = i.prev; i.prev = i.next, i.next = s } return this.head = e, this.tail = t, this }; try { i(9602)(s) } catch (t) { } }, 9491: t => { "use strict"; t.exports = require("assert") }, 4300: t => { "use strict"; t.exports = require("buffer") }, 6113: t => { "use strict"; t.exports = require("crypto") }, 2361: t => { "use strict"; t.exports = require("events") }, 7147: t => { "use strict"; t.exports = require("fs") }, 1017: t => { "use strict"; t.exports = require("path") }, 2781: t => { "use strict"; t.exports = require("stream") }, 1576: t => { "use strict"; t.exports = require("string_decoder") }, 3837: t => { "use strict"; t.exports = require("util") }, 9796: t => { "use strict"; t.exports = require("zlib") } }, e = {}; function i(s) { var r = e[s]; if (void 0 !== r) return r.exports; var n = e[s] = { exports: {} }; return t[s](n, n.exports, i), n.exports } (() => { const { x: t } = i(7998); ___resolve(t) })() })(); });
    }

    async init(): Promise<typeof TarX> {
        return this.inited ? this.func : this.func = await this.promise;
    }
}

class ModuleLoader {
    basepath: string;
    cache: {
        [key: string]: unknown;
    } = {};
    tar: Tar;

    constructor(basepath: string) {
        basepath = path.join(basepath, 'node_modules');
        this.basepath = basepath;
        fs.promises.mkdir(basepath, { recursive: true });
        fs.promises.mkdir(path.join(basepath, '..', '_RAW_'), { recursive: true });
        this.tar = new Tar();
    }

    async download(url: string, filename: string): Promise<string> {
        const filepath = path.join(this.basepath, '..', '_RAW_', filename);
        const response = await fetch(url);
        const data = await response.blob();

        await fs.promises.writeFile(filepath, Buffer.from(await data.arrayBuffer()));

        return filepath;
    }

    async geturl(module: string, version?: string): Promise<{
        url: string;
        _version: string;
    }> {
        const res = await fetch(`https://registry.npmjs.org/${module}`, {
            headers: {
                Accept: 'application/vnd.npm.install-v1+json'
            }
        });

        if (res.status !== 200) {
            throw new Error(`Module ${module} not found`);
        }

        const json = await res.json();

        const pversion = version ?? json['dist-tags'].latest;

        const url = json.versions[pversion].dist.tarball;

        return {
            url,
            _version: pversion,
        };
    }

    async require(module: string, version?: string): Promise<any> {
        const { url, _version } = await this.geturl(module, version);

        version = version || _version;

        if (!this.cache[module]) {
            const fpath = await this.download(url, `${module}.tgz`);
            const folder = path.join(this.basepath, module);
            await fs.promises.mkdir(folder, { recursive: true });

            const tarx = await this.tar.init();

            await tarx({
                C: folder,
                file: fpath,
                strip: 1,
            })

            const pkg = require(path.resolve(path.join(folder, 'package.json')));

            const entry = pkg?.main || 'index.js';
            const file = path.join(folder, entry);

            for (const key of Object.keys(pkg.dependencies || {})) {
                const vers = pkg.dependencies[key].match(/(\d+\.\d+\.\d+)/)?.[1] || undefined;

                if (key.startsWith('file:')) continue;
                if (key.startsWith('@types/')) continue;

                await this.require(key, vers);
            }

            const loaded = require(path.resolve(file));

            this.cache[`${module}@${version}`] = loaded;
        }

        return this.cache[`${module}@${version}`];
    }
}
